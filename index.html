
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>yvkm</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="yvkm">
<meta property="og:url" content="http://github.com/yvkm/index.html">
<meta property="og:site_name" content="yvkm">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yvkm">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
<meta name="generator" content="Hexo 4.2.0"></head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">yvkm</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">&lt;3 code.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="github.com/yvkm">
        </form>
      </div>
    </div>
  </div>
  <script>
    
    document.getElementById("banner").style.backgroundImage = "url(/css/images/banner.jpg)";
    
</script>
</header>
    <div class="outer">
      <section id="main">
  
    <article id="post-BeanFactory" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/03/BeanFactory/" class="article-date">
  <time datetime="2020-04-03T06:47:16.797Z" itemprop="datePublished">2020-04-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring-Framework/">Spring Framework</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/03/BeanFactory/">BeanFactory</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么是容器"><a href="#什么是容器" class="headerlink" title="什么是容器"></a>什么是容器</h2><hr>
<p>所谓容器，是指应用代码的运行框架。应用对象(大多数时候是业务对象)在容器里运行，也就是说”被容器管理”.<br>任何容器都应该提供下列服务：</p>
<ul>
<li><strong>生命周期管理</strong>:容器用于控制应用对象运行的生存周期，最起码，容器必须将“创建新对象“的逻辑从使用者那么抽象出来。更加完完善的生命周期管理可以包括诸多回调机制。在需要激活对象或容器本身准备销毁时，可以通过这些回调机制通知被管理的对象。</li>
<li>查找服务：容器应该提供某种途径，用于获得受管对象的引用。容器的查找功能将“对业务对象实现细节的了解”从使用者那里抽象出来，将其隐藏在容器内部。查找服务是容器的核心服务，也就是说容器的核心是一个工厂。</li>
<li><strong>配置管理</strong>: 容器需要提供统一的方法来配置运行其中的对象，并且允许对象的参数化。简单的配置值应该从Java中抽取出来，这样改变配置时就不需要重新编译代码。</li>
<li><strong>依赖管理</strong>: 容器不仅可以管理<code>String</code>, <code>int</code>之类的简单类型配置，还可以管理其中各个对象之间的关系。<br>通常还提供增值服务:</li>
<li><strong>企业级服务</strong>: 如事务管理和其他声明性服务</li>
<li><strong>线程管理</strong>: 对受管对象的操作，容器可以提供一个线程模型。</li>
<li><strong>对象池</strong>: 提供一个实例池来管理对象</li>
<li><strong>集群服务</strong>: 容器可以自己的阀集群的支持，客户端可以完全透明地和不同容器进行通过，就像EJB的集群一样。</li>
<li><strong>管理</strong>: 容器为其中运行的对象提供管理服务，用户可以通过管理控制台或JMX进行管理。</li>
<li><strong>暴露远程服务</strong>: 提供远程访问容器中对象的能力</li>
<li><strong>消费远程服务</strong>: 允许以透明的方式访问容器以外的远程对象</li>
<li><strong>可定制性和扩展性</strong>:允许为受管对象提供定制服务，例如安全检查等声明性服务。</li>
</ul>
<h2 id="什么是轻量级容器？"><a href="#什么是轻量级容器？" class="headerlink" title="什么是轻量级容器？"></a>什么是轻量级容器？</h2><hr>
<p>Rod Johnson认为一个轻量级容器应该具有下列特性：</p>
<ul>
<li>可以管理应用代码，而以不给应用代码强加对容器的依赖。应该可以无须修改地将遗留的代码引入容器，这各特性叫做“非侵入性”。应用对象即可以在容器内，又可以在容器外运行。达到容器无关性。</li>
<li>可以快速启动。</li>
<li>不需要任何特殊的部署步骤。</li>
<li>最小限度地依赖API，以确保可以运行在不同的环境中，例如Web容器，独立的客户端。轻量级容器应该是纯Java的，不应该依赖J2EE。</li>
<li>将对象交给轻量级容器管理时，不管工作量还是性能开销都很小，因此可以不仅在其中管理粗粒度的对象，而且也可以管理细粒度的对象。<br>轻量级容器的一个重要出发点是消除J2EE应用中众多自制的工厂和Singleton。Spring 的BeanFactory使用统一的方式装配所有应用对象，借助反射和依赖注入，被BeanFactory管理的对象根本不需要知道Spring的存在。</li>
</ul>
<h2 id="Spring-Framework中的组件"><a href="#Spring-Framework中的组件" class="headerlink" title="Spring Framework中的组件"></a>Spring Framework中的组件</h2><hr>
<p>Spring的轻量级容器最基本接口是<code>BeanFactory</code>,既然是工厂，那它必然和现实中的工厂有些类似，比如有物料，加工设备，流水线。<br>Spring Framework中众多的组件按照工厂的思想，大致可以分为两类：</p>
<ul>
<li>物料组件：<code>Resource</code>,<code>BeanDefinition</code>，最终的Bean等，它们是加工流程中被加工、被消费的组件，就像流水线上被加工的物料一样。</li>
<li>设备组件：<code>ResourceLoader</code>,<code>BeanDefinitionReader</code>,<code>BeanFactoryPostProcessor</code>,<code>BeanPostProcessor</code>,<code>InstantiationStrategy</code>,<code>BeanWrapper</code>等，就像流水线上不同环节的加工设备，对物料组件进行加工处理。</li>
</ul>
<h2 id="Spring-轻量级容器的设计"><a href="#Spring-轻量级容器的设计" class="headerlink" title="Spring 轻量级容器的设计"></a>Spring 轻量级容器的设计</h2><hr>
<p>如同商品需要有产品规格说明一样，作为轻量级的容器，也需要为它的具体实现指定基本的功能规范，这个功能规范的设计表现为接口类BeanFacoty，它体现了Srping为提供给用户使用轻量级容器所设定的最基本功能规范。<br>在Spring中，容器有两个系列：</p>
<ul>
<li>以<code>BeanFactory</code>为基础的简单容器<br>  简单容器只实现两个最基本的功能：<strong>对象创建管理</strong>和<strong>依赖注入服务</strong>。</li>
<li>以<code>ApplicationContext</code>为基础的高级容器<br>  高级容器在简单容器的基础上，增加许多特性，最明显的是资源的加载管理。     </li>
</ul>
<h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><hr>
<p><img src="images/spring-beanfactory/beanfactory.png" alt="BeanFactory的继承层次"></p>
<p><code>BeanFactory</code>继承层次初看相当复杂，但其实是非常有条理的，并且很好体现的接口单一原则。</p>
<p><strong>BeanFactory</strong>提供了</p>
<ul>
<li>查找服务(<code>getBean()</code>,<code>getAliases()</code>)</li>
<li>判断是否存在相应的Bean(<code>containesBean()</code>)</li>
<li>判断是否单例(<code>isSingleton()</code>)</li>
</ul>
<p><strong>ListableBeanFactory</strong>提供了</p>
<ul>
<li>列出工厂中所有BeanName的服务(<code>getBeanDefinitionNames()</code>)</li>
<li>获取工厂中定义Bean的数量(<code>getBeanDefinitionCount()</code>)</li>
<li>获取特定类型的所有Bean的名称(<code>getBeanDefinitonNames(Class type)</code>)<br><code>ListableBeanFactory</code>可以获得被管理对象的相关信息，利用这个接口可以实现一个特殊的Bean：这个Bean需要与一组别的对象协作，并且只有到时运行时才知道其协作的究竟是哪些对象。<br><code>ListableBeanFactory</code>有一个缺点是，不可以获取父容器中的Bean信息。</li>
</ul>
<p><strong>HierarchicalBeanFactory</strong>提供了</p>
<ul>
<li>获取父工厂的服务(<code>getParentBeanFactory()</code>)</li>
<li>判断Bean是否属于当前工厂(<code>containsLocalBean()</code>）</li>
</ul>
<p><strong>ConfigurableBeanFactory</strong>提供了</p>
<ul>
<li>添加Bean处理器的服务(<code>addBeanPostProcessor()</code>)</li>
<li>添加父工厂服务(<code>setParentBeanFactory()</code>) </li>
<li>注册别名的服务(<code>registerAlias()</code>)</li>
<li>注册Bean作用域的服务(<code>registerScope()</code>)</li>
<li>…<br><code>ConfigurableBeanFactory</code>的提供的服务从接口名就可知，用于配置<code>BeanFactory</code>各类API。</li>
</ul>
<p><strong>AutowireCapableBeanFactory</strong>提供了</p>
<ul>
<li>创建Bean的服务(<code>createBean()</code>)</li>
<li>依赖注入的服务(<code>autowireBean()</code>)</li>
<li>Bean后处理服务(<code>applyBeanPostProcessorsBeforeInitialization()</code>和<code>applyBeanPostProcessorsAfterInitialization()</code>)</li>
<li>解析Bean依赖关系的服务(<code>resolveDependency()</code>)</li>
<li>…<br><code>AutowireCapableBeanFactory</code>提供的服务与Bean的创建和依赖注入相关</li>
</ul>
<p><strong>BeanDefinitionRegistry</strong>提供了</p>
<ul>
<li>注册<code>BeanDefinition</code>的服务(<code>registerBeanDefinition()</code>)</li>
<li>获取/删除<code>BeanDefinition</code>的服务(<code>remove/getBeanDefinition()</code>)</li>
<li>判断指定的<code>BeanDefinition</code>是否存在的服务(<code>containsBeanDefinitions</code>)</li>
</ul>
<p><strong>SingletonBeanRegistry</strong>提供了 </p>
<ul>
<li>注册单例Bean的服务(<code>registerSingleton()</code>)</li>
<li>获取单例Bean的服务(<code>getSingleton()</code>)</li>
<li>判断对应的单例是否存在(<code>containsSingleton()</code>)</li>
<li>获取所有单例的BeanName(<code>getSingletonNames()</code>)</li>
<li>获取所有单例的数量(<code>getSingletonCount()</code>)</li>
</ul>
<p><strong>DefaultListableBeanFactory</strong>是Spring提供的<code>BeanFactory</code>默认实现,它实现了上面的所有接口，也就是说它可以提供这些接口的定义的服务。</p>
<p>下面是一个简单的使用流程：</p>
<ol>
<li>用户调用<code>getBean()</code>时指定需要获取Bean的类型。</li>
<li><code>DefaultListbaleBeanFactory</code>通过<code>resolveNameBean</code>对指定的Bean类型解析得到name.</li>
<li><code>DefaultListableBeanFactory</code>调用<code>doGetBean</code></li>
<li><code>doGetBean</code>里面包含了<code>BeanFactory</code>的核心逻辑，当<code>doGetBean</code>完成返回一个<code>Bean</code>给用户。</li>
</ol>
<p>下面是<code>doGetBean</code>的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, @Nullable <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">			@Nullable <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将解析得到的name进行转换,用户可能使用了&amp;factoryBean的名，所以需要去除这个&amp;</span></span><br><span class="line">	<span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">	Object bean;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 因为实现了SingletonBeanRegistry，所以创建的SingletonBean会注册到SingletonBeanRegistry的缓存中</span></span><br><span class="line">	<span class="comment">// 因此先从这个缓存中获取 </span></span><br><span class="line">	Object sharedInstance = getSingleton(beanName);</span><br><span class="line">	<span class="comment">// 如果不为空</span></span><br><span class="line">	<span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 日志记录</span></span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			<span class="comment">// 如果这个Bean还在创建中，</span></span><br><span class="line">			<span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">				logger.trace(<span class="string">"Returning eagerly cached instance of singleton bean '"</span> + beanName +</span><br><span class="line">						<span class="string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 如果Bean已经创建好</span></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				logger.trace(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 因为这个Bean可能是FactoryBean，需要再进一步进行判断</span></span><br><span class="line">		bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// SingletonBeanRegistry的缓存中没有对应的单例Bean时，</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 如果需要获取的Bean定义为Prototype时，并且这个Bean正在创建过程中，则抛出异常</span></span><br><span class="line">		<span class="comment">// 也就是说Spring无法解决prototype类型Bean的循环依赖问题</span></span><br><span class="line">		<span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 当前工厂没有相应的单例Bean，那么可以去父类中查找</span></span><br><span class="line">		<span class="comment">// 实现了HierarchicalBeanFactory，可以获取父工厂</span></span><br><span class="line">		BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">		<span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">			<span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">			String nameToLookup = originalBeanName(name);</span><br><span class="line">			<span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">				<span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">						nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">				<span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">				<span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// typeCheckOnly表示这dogetBean调用是否只是用于类型检查，而不是实际使用。</span></span><br><span class="line">		<span class="comment">// 实际使用中基本就是typeCheckOnly=false</span></span><br><span class="line">		<span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">			<span class="comment">// 将用户请求的Bean标记为正在创建或正在创建,这样Spring可以重复创建一个指定的Bean进行优化</span></span><br><span class="line">			markBeanAsCreated(beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 通过beanName获取BeanDefinition，这个BeanDefinition就是封装了我们定义在XML或@Bean, @component等中的信息</span></span><br><span class="line">			<span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">			<span class="comment">// 检查即将创建的bean是否是抽象类。</span></span><br><span class="line">			checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Guarantee initialization of beans that the current bean depends on.,</span></span><br><span class="line">			<span class="comment">// 获取Bean的依赖关系</span></span><br><span class="line">			String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">			<span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">					<span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">								<span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// 注册依赖关系</span></span><br><span class="line">					registerDependentBean(dep, beanName);</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="comment">// 先初始化被依赖的Bean</span></span><br><span class="line">						getBean(dep);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">								<span class="string">"'"</span> + beanName + <span class="string">"' depends on missing bean '"</span> + dep + <span class="string">"'"</span>, ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Create bean instance.</span></span><br><span class="line">			<span class="comment">// 开始创建bean</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果是单例</span></span><br><span class="line">			<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">				sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">						<span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">						<span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">						<span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">						destroySingleton(beanName);</span><br><span class="line">						<span class="keyword">throw</span> ex;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">				<span class="comment">// 同样，因为这个Bean可能是FactoryBean并不是用户想要的，所以Spring还需要进一步处理</span></span><br><span class="line">				bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果是prototype</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">				<span class="comment">// It's a prototype -&gt; create a new instance.</span></span><br><span class="line">				Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="comment">// 前置处理</span></span><br><span class="line">					beforePrototypeCreation(beanName);</span><br><span class="line">					prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">finally</span> &#123;</span><br><span class="line">					<span class="comment">// 后置处理</span></span><br><span class="line">					afterPrototypeCreation(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 同样，因为这个Bean可能是FactoryBean并不是用户想要的，所以Spring还需要进一步处理</span></span><br><span class="line">				bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 其他作用域 如request session...</span></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				String scopeName = mbd.getScope();</span><br><span class="line">				<span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">				<span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">						beforePrototypeCreation(beanName);</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">finally</span> &#123;</span><br><span class="line">							afterPrototypeCreation(beanName);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;);</span><br><span class="line">					bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">							<span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; consider "</span> +</span><br><span class="line">							<span class="string">"defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,</span><br><span class="line">							ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以算出<code>doGetBean</code>最后的核心逻辑交给了<code>doCreateBean</code>和<code>getObjectForBeanInstance</code>.下面先解析<code>doCreateBean</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略部分代码</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">		<span class="comment">// 给BeanPostProcessor一个机会去创建proxy,而不是普通的Bean</span></span><br><span class="line">		<span class="comment">// 这里就是AOP插入到容器的入口,@EnableAspectJAutoProxy最终导入的类是一个BeanPostProcessor。</span></span><br><span class="line">		Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">		<span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> bean;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">				<span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 根据BeanDefinition,beanName和用户指定的参数创建一个普通的Bean</span></span><br><span class="line">		Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> beanInstance;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">		<span class="comment">// A previously detected exception with proper bean creation context already,</span></span><br><span class="line">		<span class="comment">// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span></span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">				mbdToUse.getResourceDescription(), beanName, <span class="string">"Unexpected exception during bean creation"</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的<code>doCreateBean</code>委托给了重载<code>doCreateBean</code>方法创建bean:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建Bean</span></span><br><span class="line">	BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">		<span class="comment">// 如果是单例，清除缓存</span></span><br><span class="line">		instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 创建BeanWrapper，用户想要的bean被封装在BeanWrapper里</span></span><br><span class="line">		<span class="comment">// 使用工厂访求，构造器</span></span><br><span class="line">		instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 提取用户想要的bean,注意，这个bean并没有达到最终状态，还需要进行依赖注入工作。</span></span><br><span class="line">	<span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">	Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">	<span class="keyword">if</span> (beanType != NullBean<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">		mbd.resolvedTargetType = beanType;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">	<span class="comment">// 在运行时对BeanDefinition进行后处理，BeanFactoryPostProcessor同样可以对BeanDefinition进行处理。</span></span><br><span class="line">	<span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">						<span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">			mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 解决循环引用 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果这个bean是单例，并且允许循环引用(这个属性默认是true),并且这个bean正在创建中</span></span><br><span class="line">	<span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">			isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line">					<span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize the bean instance.</span></span><br><span class="line">	Object exposedObject = bean;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 对bean进入依赖注入操作,从BeanDefinition中获取依赖</span></span><br><span class="line">		<span class="comment">// 这个过程相当复杂，这里暂未展开</span></span><br><span class="line">		<span class="comment">// 需要注意的是依赖过程会触发被依赖的Bean的初始化,这时一个递归的过程.</span></span><br><span class="line">		populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">		<span class="comment">// 依赖注入完成后，依次调用bean实现的Aware接口方法，BeanPostProcessor的postProcessBeforeInitialization方法和Bean定义的init method</span></span><br><span class="line">		exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">			<span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">					mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//  到此最终状态的Bean已经创建完成</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 解决循环引用 */</span></span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">		<span class="comment">// 从最终缓存单例的map中获取Bean，</span></span><br><span class="line">		<span class="comment">// 注意SingletonBeanRegistry中有两个map，一个用于保存Bean未完成创建的引用，</span></span><br><span class="line">		Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// </span></span><br><span class="line">			<span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">				exposedObject = earlySingletonReference;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">				String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">				Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">				<span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">					<span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">						actualDependentBeans.add(dependentBean);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 如果在循环引用中有一方被AOP增强了</span></span><br><span class="line">				<span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">							<span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">							StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">							<span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line">							<span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line">							<span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line">							<span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register bean as disposable.</span></span><br><span class="line">	<span class="comment">// 如果Bean定义了destroy方法，将其注册，在销毁时调用destory方法</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">				mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成<code>doCreateBean</code>后，还需要在<code>getObjectForBeanInstance</code>中进一步处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectForBeanInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果用户是指定了name有FactoryBean前缀 &amp; 时</span></span><br><span class="line">	<span class="comment">// 场景：ctx.getBean("&amp;beanName")</span></span><br><span class="line">	<span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">		<span class="comment">// 如果FactoryBean的getObject或定义的Bean工厂方法返回的是null</span></span><br><span class="line">		<span class="keyword">if</span> (beanInstance <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">			<span class="keyword">return</span> beanInstance;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果创建的beanInstance不是FactoryBean，抛出异常，因为与用户的预期不一致。</span></span><br><span class="line">		<span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanIsNotAFactoryException(beanName, beanInstance.getClass());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 经过上面的过滤已经说明用户就是想要FactoryBean的引用，并且这个BeanInstance就是FactoryBean</span></span><br><span class="line">		<span class="keyword">if</span> (mbd != <span class="keyword">null</span>) &#123;</span><br><span class="line">			mbd.isFactoryBean = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> beanInstance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果BeanInstance不是FactoryBean，直接返回beanInstance</span></span><br><span class="line">	<span class="comment">// 场景：ctx.getBean("beanName")</span></span><br><span class="line">	<span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">		<span class="keyword">return</span> beanInstance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// BeanInstance是FactoryBean，则从FactoryBean中创建用户需要的Bean</span></span><br><span class="line">	<span class="comment">// 场景： ctx.getBean("beanName"),这个beanName对应的是一个FactoryBean</span></span><br><span class="line">	Object object = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (mbd != <span class="keyword">null</span>) &#123;</span><br><span class="line">		mbd.isFactoryBean = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 从缓存中获取</span></span><br><span class="line">		object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 无法从缓存中获取</span></span><br><span class="line">	<span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// Return bean instance from factory.</span></span><br><span class="line">		FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">		<span class="comment">// Caches object obtained from FactoryBean if it is a singleton.</span></span><br><span class="line">		<span class="keyword">if</span> (mbd == <span class="keyword">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">			mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">boolean</span> synthetic = (mbd != <span class="keyword">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line">		<span class="comment">// 最终调用FactoryBean#getObject()返回bean对象</span></span><br><span class="line">		<span class="comment">// 这里同样可以作为AOP的入口，Spring提供的ProxyFactoryBean就是这样做的。</span></span><br><span class="line">		object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr>
<ul>
<li>BeanFactory并没有进行Bean配置文件的加载及解析，它仅提供了注册BeanDefinition的API,这部分工作交给了BeanDefinitionReader进行处理。</li>
<li>在BeanFactory中，Bean的创建是在调用getBean()时触发的，如果直接使用BeanFactory，所有的Bean都是延迟初始化的。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://github.com/yvkm/2020/04/03/BeanFactory/" data-id="ck8jvao4l0000ooap3x69got1" class="article-share-link" data-share="baidu" data-title="BeanFactory">分享到</a>
      

      

      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BeanFactory/" rel="tag">BeanFactory</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring-Framework/" rel="tag">Spring Framework</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Redis分布式锁" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/02/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" class="article-date">
  <time datetime="2020-04-02T11:29:40.047Z" itemprop="datePublished">2020-04-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Redis/">Redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/02/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">Redis分布式锁</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>为什么要使用分布式锁？<br>使用锁的目的是确保在可能尝试执行同一工作的多个节点中，只有一个节点实际执行。这项工作可能是将数据写入共享的存储系统，可能是执行一些计算，调用某些外部API等。从高层次上讲，在分布式应用程序中使用锁有两个原因：<strong>效率</strong>和<strong>正确性</strong>。</p>
<ul>
<li><strong>效率</strong>: 锁可以避免不必要地重复执行两次相同的工作(例如，一些昂贵的计算).如果锁定失败并且两个节点最终完成相同的工作，则成本会增加(计算多一次所产生的费用)或带有不便(用户最终两次收到相同的邮件).</li>
<li><strong>正确性</strong>： 锁可以防止并发的进程扰乱系统的状态，如果锁定失败，并且两个节点同时处理一条数据，则结果是数据丢失、永久性不一致、文件损坏、给患者的药物剂量错误等其他严重的问题。<br>在使用锁时，你需要非常清楚在哪种情况下。</li>
</ul>
<p>下面使用Redis实现分布式锁，从简单到复杂，解析其中存在的问题。</p>
<h2 id="level-1"><a href="#level-1" class="headerlink" title="level 1"></a>level 1</h2><hr>
<p><code>setnx</code> + <code>del</code></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ setnx <span class="keyword">lock</span> <span class="literal">true</span></span><br><span class="line">... <span class="keyword">do</span> something</span><br><span class="line">$ del <span class="keyword">lock</span></span><br></pre></td></tr></table></figure>
<p><strong>存在问题</strong></p>
<ul>
<li>如果在<code>setnx</code>和<code>del</code>之间出现异常，导致<code>del</code>没有执行，这样锁不会被释放了。</li>
</ul>
<h2 id="level-2"><a href="#level-2" class="headerlink" title="level 2"></a>level 2</h2><hr>
<p><code>setnx</code> + <code>expire</code> + <code>del</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ setnx <span class="keyword">lock</span> <span class="literal">true</span></span><br><span class="line">$ <span class="keyword">expire</span> <span class="keyword">lock</span> <span class="number">5</span></span><br><span class="line">... <span class="keyword">do</span> something</span><br><span class="line">$ del <span class="keyword">lock</span></span><br></pre></td></tr></table></figure>
<p><strong>存在问题</strong></p>
<ul>
<li>如果<code>setnx</code>和<code>expire</code>之间服务器进程突然停止，锁同样不会被释放。根源在于<code>setnx</code>和<code>expire</code>是两条指令。</li>
</ul>
<h2 id="level-3"><a href="#level-3" class="headerlink" title="level 3"></a>level 3</h2><hr>
<p><code>set</code>扩展参数 + <code>del</code></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">set</span> <span class="keyword">lock</span> <span class="literal">true</span> ex <span class="number">5</span> nx</span><br><span class="line">... <span class="keyword">do</span> something</span><br><span class="line">$ del <span class="keyword">lock</span></span><br></pre></td></tr></table></figure>
<p><strong>存在问题</strong></p>
<ul>
<li>超时问题：如果线程1在<code>set</code>和<code>del</code>之间执行的时间超过5s, 这时锁已经过期了。线程2可以重新设置这把锁,问题出现在，线程1竟然去释放了线程2设置的锁，这时假如线程3申请加锁，就会通过。因此，redis分布式锁不要用于执行较长的任务。</li>
</ul>
<h2 id="level-4"><a href="#level-4" class="headerlink" title="level 4"></a>level 4</h2><hr>
<p>通过对比加锁前和删除锁前的随机数值是否一致再删除key。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 伪码</span><br><span class="line">flag = Random.nextInt();</span><br><span class="line"><span class="keyword">if</span> (redis.set(key, flag, nx=<span class="keyword">true</span>, ex=<span class="number">5</span>)) &#123;</span><br><span class="line">	doSomething();</span><br><span class="line">	redis.delIfEquals(key, tag); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Redis不存在delIfEquals这样的指令.需要Lua脚本来处理，因为Lua脚本可以保证连接多个指令的原子性。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># defIfEquals</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>, KEYS[<span class="number">1</span>] == ARGS[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">	<span class="keyword">return</span> redis.call(<span class="string">"del"</span>, KEYS[<span class="number">1</span>]) </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><strong>存在问题</strong></p>
<ul>
<li>如果线程在持有锁的情况下再次请求加锁,目前是没有办法完成的。即存在可重入问题。</li>
</ul>
<h2 id="level-5"><a href="#level-5" class="headerlink" title="level 5"></a>level 5</h2><hr>
<p>基于ThreadLocal和引用计数实现可重入锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisReentrantLock</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 当前线程持有的锁(String)和引用数(Integer)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> ThreadLocal&lt;Map&lt;String,Integer&gt;&gt; currentLockers = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">	<span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">RedisReentrantLock</span><span class="params">(Jedis jedis)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.jedis = jedis;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">_lock</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> jedis.set(key, <span class="string">""</span>, <span class="string">"nx"</span>, <span class="string">"ex"</span>, <span class="number">5L</span>) != <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">publci <span class="keyword">void</span> <span class="title">_unlock</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">		jedis.del(key);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Map&lt;String Integer&gt; currentLockers() &#123;</span><br><span class="line">		Map&lt;String,Integer&gt; refs = currentLockers.get();</span><br><span class="line">		<span class="keyword">if</span>(refs != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> refs;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 初始化ThreadLocal </span></span><br><span class="line">		lockers.set(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">		<span class="keyword">return</span> lockers.get();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">		Map&lt;String Integer&gt; refs = currentLockers()</span><br><span class="line">		Integer refCnt = refs.get(key);</span><br><span class="line">		<span class="comment">// 如果不为空，说明已经加过锁,引用数加1，并返回.</span></span><br><span class="line">		<span class="keyword">if</span>(refCnt != <span class="keyword">null</span>) &#123;</span><br><span class="line">			refs.put(key, refCnt+<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果refCnt为空，说明首次加锁</span></span><br><span class="line">		<span class="keyword">boolean</span> ok = <span class="keyword">this</span>._lock(key);</span><br><span class="line">		<span class="keyword">if</span>(!ok) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 加锁完成</span></span><br><span class="line">		refs.put(key, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unlock</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">		Map&lt;String Integer&gt; refs = currentLockers();</span><br><span class="line">		Integer refCnt = refs.get(key);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 引用数为空是不可能解锁的</span></span><br><span class="line">		<span class="keyword">if</span>(refCnt ==<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		refCnt -= <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(refCnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			refs.put(key, refCnt);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 引用数为空，删除锁</span></span><br><span class="line">			refs.remove(key);</span><br><span class="line">			<span class="keyword">this</span>._unlock(key);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>存在问题</strong></p>
<ul>
<li>加入可重入性后复杂度明显提高，而且上面的代码并不完善，还需要考虑过期问题,添加随机数。通常在编写业务方法时，可以通过调整业务逻辑结构来避免可重入锁的使用。</li>
<li>在集群环境下不安全，在Sentinel集群中，主节点挂掉，从节点会取而代之，但客户端是无法知道的。如果线程在主节点为成功申请了一把锁了，但是这把锁没有来得及同步到从节点就挂掉。然后从节点变成主节点，这个新节点并没有这把锁，所以另外一个线程请求加锁会立即成功。这样导致系统中同样一把锁被两个线程持有。幸运的是，这种不安全仅会在故障转移(failover)下会产生，而且时间极短，业务系统多数情况可以容忍。</li>
</ul>
<h2 id="level-6"><a href="#level-6" class="headerlink" title="level 6"></a>level 6</h2><hr>
<p>Antirez在Redis中实现了Redlock算法可以解决上述问题，但是流程比较复杂。好在很多开源的libary做了良好的封装，开箱即用。为了使用Redlock，需要提供多个Redis实例，这些实例之前相互独立没有主从关系，同很多分布式算法一样，Redlock也使用所谓的<strong>大多数机制</strong>。</p>
<p>加锁时，它会向过半节点发送<code>set(key, value, nx=true,ex=xx)</code>指令，只要过半节点set成功，那就认为加锁成功。释放锁时，需要所有节点发送del指令。不过Redlock算法还需要考虑出错重试，时钟漂移等众多细节问题，同时因为Redlock需要向多个节点进行读写，意味着相比单实例Redis性能会下降。<br><strong>权衡</strong><br>如果很在乎高可用性，希望挂一个redis实例完全不受影响,那么就应该考虑使用Redlock.其代价是，需要更多的Redis实例，带来的是性能的下降，并且代码上还需要引入额外的libary，运维上也需要特殊对待，这些都是应该纳入考虑的成本。</p>
<h2 id="争议"><a href="#争议" class="headerlink" title="争议"></a>争议</h2><p>Martin在<a href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html" target="_blank" rel="noopener">how to build distributed locking</a>一文中认为：RedLock虽然已经提供了相当完美的锁服务，但在Java的应用中，JVM的GC可是随时都有可能运行的，一个节点完全有可能在获取锁后由于GC的原因(<code>stop-the-world</code>)，导致暂停很长的时间以致锁超时了。此时这个节点并没有意识到锁已经超时，它可能会继续进行一些不安全的操作。<br><img src="images/redis-lock/unsafe-lock.png" alt="由于GC引起的锁超时问题"></p>
<p>他认为，引入一个标记(token)来保护锁，标记就是一个递增的数字，每次获得锁后递增一次。<br><img src="images/redis-lock/fencing-tokens.png" alt="利用标记保护锁"></p>
<p>当客户端1成功锁时，还获取到一个33号标记,随后它进行长暂停，锁随之超时。其后，客户端2获得锁和34号标记，然后进行存储操作。当客户端1恢复执行时，进行存储操作，然而存储服务器记住它已经处理了具有更高标记的操作(34),因此拒绝执行客户端1的请求。然而，这种RedLock并不提供生成标记的操作。</p>
<p>而Antiez对这篇文章提出了一些反驳的观点<a href="http://antirez.com/news/101" target="_blank" rel="noopener">Is Redlock safe</a>?</p>
<p>内容来自：</p>
<ul>
<li>Redis尝试历险：核心原理和应用实践</li>
<li><a href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html" target="_blank" rel="noopener">how to do distributed locking</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://github.com/yvkm/2020/04/02/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" data-id="ck8jvao5d000cooap6t0t0pe1" class="article-share-link" data-share="baidu" data-title="Redis分布式锁">分享到</a>
      

      

      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Git from the inside out" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/02/Git%20from%20the%20inside%20out/" class="article-date">
  <time datetime="2020-04-02T05:47:11.859Z" itemprop="datePublished">2020-04-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Git/">Git</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/02/Git%20from%20the%20inside%20out/">深入浅出Git原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>经作者同意翻译成中文，有所增删。欢迎指正不足之处，转载注明出处。<a href="https://codewords.recurse.com/issues/two/git-from-the-inside-out" target="_blank" rel="noopener">原文链接</a> <a href="https://maryrosecook.com/" target="_blank" rel="noopener">作者</a></p>
<p>本文解析Git的工作原理，假定你已经能够熟练使用Git对你的项目进行版本控制。</p>
<p>本文着重介绍Git底层使用的图结构(graph structure)和该图结构的属性决定了Git的特性或行为。对Git的理解不能建立在经验上，而是建立在Git的真正实现上。从Git的实现角度去理解Git可以让你更加清楚Git做了什么，它正在做什么，它将要做什么。</p>
<p>阅读前需知：</p>
<ul>
<li><strong><a href="https://slangit.com/meaning/tltr" target="_blank" rel="noopener">TLTR</a></strong></li>
<li>Git的对象和引用是以文件形式存在的。</li>
<li>Git使用哈希值唯一表示一个对象。</li>
</ul>
<h2 id="创建一个项目"><a href="#创建一个项目" class="headerlink" title="创建一个项目"></a>创建一个项目</h2><hr>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~ $ <span class="keyword">mkdir</span> git</span><br><span class="line">~ $ <span class="keyword">cd</span> git</span><br><span class="line">git $ <span class="keyword">mkdir</span> <span class="keyword">alpha</span></span><br><span class="line">git $ <span class="keyword">cd</span> <span class="keyword">alpha</span></span><br></pre></td></tr></table></figure>

<p>创建一个项目,根目录为 <code>alpha</code></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alpha <span class="variable">$</span> mkdir <span class="keyword">data</span></span><br><span class="line">alpha <span class="variable">$</span> printf <span class="string">'a'</span> &gt; <span class="keyword">data</span>/letter.txt</span><br></pre></td></tr></table></figure>


<p>进入根目录<code>alpha</code>后，创建一个<code>data</code>目录，并在<code>data</code>创建一个<code>letter.txt</code>文件，<code>letter.txt</code>中包含一个字符 <code>a</code>.当前目录的结构如下：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alpha $ tree</span><br><span class="line">.</span><br><span class="line">`<span class="comment">-- data</span></span><br><span class="line">    `<span class="comment">-- letter.txt</span></span><br></pre></td></tr></table></figure>


<h2 id="初始化Git仓库"><a href="#初始化Git仓库" class="headerlink" title="初始化Git仓库"></a>初始化Git仓库</h2><hr>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alpha $ git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> <span class="regexp">/root/gi</span>t<span class="regexp">/alpha/</span>.git<span class="regexp">/</span></span><br></pre></td></tr></table></figure>

<p><code>git init</code>将当前目录变成一个Git仓库。Git在<code>alpha</code>目录下创建了一个名为<code>.git</code>的目录并在这个目录下创建一些文件。这些文件包含了Git配置和项目历史等所有信息。这些文件都是普通文件，没什么特别的。用户可以使用编辑器编辑它们。这时<code>alpha</code>目录的结构如下所示：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">alpha $ tree -a</span><br><span class="line">.</span><br><span class="line">|<span class="string">-- data</span></span><br><span class="line">|<span class="string">   `-- letter.txt</span></span><br><span class="line"><span class="string">`-- .git</span></span><br><span class="line"><span class="string">    </span>|<span class="string">-- branches</span></span><br><span class="line"><span class="string">    </span>|<span class="string">-- config</span></span><br><span class="line"><span class="string">    </span>|<span class="string">-- description</span></span><br><span class="line"><span class="string">    </span>|<span class="string">-- HEAD</span></span><br><span class="line"><span class="string">    </span>|<span class="string">-- hooks</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">-- applypatch-msg.sample</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">-- commit-msg.sample</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">-- fsmonitor-watchman.sample</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">-- post-update.sample</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">-- pre-applypatch.sample</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">-- pre-commit.sample</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">-- prepare-commit-msg.sample</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">-- pre-push.sample</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">-- pre-rebase.sample</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">-- pre-receive.sample</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   `-- update.sample</span></span><br><span class="line"><span class="string">    </span>|<span class="string">-- info</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   `-- exclude</span></span><br><span class="line"><span class="string">    </span>|<span class="string">-- objects</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">-- info</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   `-- pack</span></span><br><span class="line"><span class="string">    `-- refs</span></span><br><span class="line"><span class="string">        </span>|<span class="string">-- heads</span></span><br><span class="line"><span class="string">        `-- tags</span></span><br></pre></td></tr></table></figure>
<p>在这个目录下，<code>.git</code>目录及其所拥有的内容都是Git的，除此之外的文件称为工作副本(<code>working copy</code>),它们属于用户，工作副本位于工作空间(<code>workspace</code>)中。</p>
<h2 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h2><hr>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">alpha</span> $ git <span class="keyword">add </span><span class="meta">data</span>/letter.txt</span><br></pre></td></tr></table></figure>

<p>用户运行<code>git add</code>将<code>data/letter.txt</code> 添加到<code>index</code>中，这步操作有两个影响：</p>
<ol>
<li>Git在<code>.git/objects</code>目录下创建一个<code>blob</code>格式的文件，这个blob文件代表一个Blob对象。</li>
</ol>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alpha $ tree .git/objects</span><br><span class="line">.git/objects</span><br><span class="line">|<span class="comment">-- 2e</span></span><br><span class="line">|   `<span class="comment">-- 65efe2a145dda7ee51d1741299f848e5bf752e</span></span><br><span class="line">|<span class="comment">-- info</span></span><br><span class="line">`<span class="comment">-- pack</span></span><br></pre></td></tr></table></figure>

<p>这个blob文件包含了<code>data/letter.txt</code>文件中被压缩后的内容。blob文件名来源于文件内容的哈希值。这个哈希值唯一标识了文件中的内容。例如Git 对 <code>a</code>进行哈希运算得到<code>2e65efe2a145dda7ee51d1741299f848e5bf752e</code>.这个哈希值的前两个字符用于.git/objects下的目录创建一个目录:<code>.git/objects/2e</code>.剩余的字符用于命名这个blob文件。</p>
<p>注意：刚才已经将文件添加到Git的objects目录下，如果用户将<code>data/letter.txt</code>从工作空间中删除，这些数据仍然安全保存在Git中。</p>
<ol start="2">
<li>Git 将要保存的文件的信息添加到 <code>index</code> (暂存区）中，<code>index</code>是一个列表，它包含了所有被Git追踪的文件。这个列表以文件的形式存储在<code>.git/index</code>中。文件中的每一行包含着一个文件名和这个文件内容对应的哈希值，刚才<code>git add</code>后<code>index</code>文件中的添加的内容大致如下：</li>
</ol>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 通过文件名可以找到对应的Blob对象。</span></span><br><span class="line"><span class="class"><span class="keyword">data</span>/letter.txt 2e65efe2a145dda7ee51d1741299f848e5bf752e</span></span><br></pre></td></tr></table></figure>

<p>当用户再创建一个文件<code>data/number.txt</code>且输入<code>1234</code></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alpha <span class="variable">$</span> printf <span class="string">'1234'</span> &gt; <span class="keyword">data</span>/number.txt</span><br></pre></td></tr></table></figure>

<p>此时工作空间下的文件有:</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alpha $ tree</span><br><span class="line">.</span><br><span class="line">`<span class="comment">-- data</span></span><br><span class="line">    |<span class="comment">-- letter.txt</span></span><br><span class="line">    `<span class="comment">-- number.txt</span></span><br></pre></td></tr></table></figure>

<p>将文件添加到Git中</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">alpha</span> $ git <span class="keyword">add </span><span class="meta">data</span></span><br></pre></td></tr></table></figure>

<p><code>git add</code>命令创建了另一个新的blob对象，并且包含<code>data/number.txt</code>的内容，并且在<code>index</code>中添加一项</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span>/letter.txt 2e65efe2a145dda7ee51d1741299f848e5bf752e</span></span><br><span class="line"><span class="meta"># 新增</span></span><br><span class="line"><span class="class"><span class="keyword">data</span>/number.txt 274c0052dd5408f8ae2bc8440029ff67d79bc5c3</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，只有在data目录下的文件添加到<code>index</code>中，data目录并没有添加到<code>index</code>中。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alpha <span class="variable">$</span> printf <span class="string">'1'</span> &gt; <span class="keyword">data</span>/number.txt</span><br><span class="line">alpha <span class="variable">$</span> git add <span class="keyword">data</span></span><br></pre></td></tr></table></figure>

<p>用户将<code>data/number.txt</code>中的<code>1234</code>改为<code>1</code>.这时Git会重新在<code>.git/objects</code>中创建一个新的blob对象，并且更新<code>index</code>，将哈希值改为根据新内容生成的哈希值。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">alpha $ printf '<span class="number">1</span>tree .git/objects</span><br><span class="line">.git/objects</span><br><span class="line">|<span class="comment">-- 27</span></span><br><span class="line">|   `<span class="comment">-- 4c0052dd5408f8ae2bc8440029ff67d79bc5c3</span></span><br><span class="line">|<span class="comment">-- 2e</span></span><br><span class="line">|   `<span class="comment">-- 65efe2a145dda7ee51d1741299f848e5bf752e</span></span><br><span class="line">|<span class="comment">-- 56</span></span><br><span class="line">|   `<span class="comment">-- a6051ca2b02b04ef92d5150c9ef600403cb1de</span></span><br><span class="line">|<span class="comment">-- info</span></span><br><span class="line">`<span class="comment">-- pack</span></span><br></pre></td></tr></table></figure>

<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><hr>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alpha $ git <span class="keyword">commit</span> -m <span class="string">'a1'</span></span><br><span class="line">[<span class="keyword">master</span> (root-<span class="keyword">commit</span>) a89ea18] a1</span><br><span class="line"> <span class="number">2</span> files <span class="keyword">changed</span>, <span class="number">2</span> insertions(+)</span><br><span class="line"> <span class="keyword">create</span> <span class="keyword">mode</span> <span class="number">100644</span> <span class="keyword">data</span>/letter.txt</span><br><span class="line"> <span class="keyword">create</span> <span class="keyword">mode</span> <span class="number">100644</span> <span class="keyword">data</span>/number.txt</span><br></pre></td></tr></table></figure>
<p>用户将这次提交注释记为<code>a1</code>(后面将以<code>commit a1</code>表示本次提交生成的commit对象或表示注释为a1的提交，请视上下文语义确定其含义)。. <code>git commit</code>完成了三个动作：</p>
<ul>
<li>创建了一个树形图表示这次提交的项目版本内容。</li>
<li>创建一个commit对象。</li>
<li>将HEAD指向当前分支最新的commit对象</li>
</ul>
<h2 id="创建树形图"><a href="#创建树形图" class="headerlink" title="创建树形图"></a>创建树形图</h2><hr>
<p>Git通过<code>index</code>创建树形图来记录当前项目的状态，相当于记录了一个快照。这个树形图记录了项目中所有文件的<code>位置</code>和<code>内容</code>。</p>
<p>这个树形图由两种对象组成：blob和tree.</p>
<p>Blob对象已经通过<code>git add</code>储存在<code>.git/objects</code>中，它们代表<strong>文件的内容</strong>。</p>
<p>Tree对象在<code>git commit</code>时生成，tree对象表示<strong>工作空间中的目录</strong>。</p>
<p>下面是<code>git commit</code>生成的三个对象及内容。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">alpha $ tree .git/objects</span><br><span class="line"><span class="comment"># 比之前多了下面三个对象。</span></span><br><span class="line">.git/objects</span><br><span class="line">|<span class="comment">-- ... </span></span><br><span class="line">|<span class="comment">-- 0e</span></span><br><span class="line">|   `<span class="comment">-- ed1217a2947f4930583229987d90fe5e8e0b74</span></span><br><span class="line">|<span class="comment">-- a8</span></span><br><span class="line">|   `<span class="comment">-- 9ea183a48e484c318335fd25c8adcc82608c35</span></span><br><span class="line">|<span class="comment">-- ff</span></span><br><span class="line">|   `<span class="comment">-- e298c3ce8bb07326f888907996eaa48d266db4</span></span><br><span class="line">|<span class="comment">-- info</span></span><br><span class="line">`<span class="comment">-- pack</span></span><br></pre></td></tr></table></figure>

<p>下面是新提交生成的tree对象记录的内容，这些内容描述data目录的信息.</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alpha $ git cat-file -t <span class="number">0</span>eed</span><br><span class="line">tree</span><br><span class="line">alpha $ git cat-file -p <span class="number">0</span>eed</span><br><span class="line"><span class="number">100644</span> blob <span class="number">2e65</span>efe2a145dda7ee51d1741299f848e5bf752e    letter.txt</span><br><span class="line"><span class="number">100644</span> blob <span class="number">56</span>a6051ca2b02b04ef92d5150c9ef600403cb1de    number.txt</span><br></pre></td></tr></table></figure>

<p>这两条记录分为四部分：</p>
<ul>
<li><code>100644</code>表示文件的权限</li>
<li><code>blob</code>表示这个文件的内容由blob表示，而不是tree。</li>
<li><code>2e65...2e</code> 和<code>56a6...de</code>表示blob对象的哈希值,这些值唯一确定一个blog对象。</li>
<li><code>letter.txt</code> 和 <code>number.txt</code>表示文件名。</li>
</ul>
<p>下面是一个表示<code>alpha</code>目录的tree对象，它表示项目的根目录</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alpha</span> $ git <span class="keyword">cat</span>-<span class="keyword">file</span> -p ffe2</span><br><span class="line">040000 tree 0eed1217a2947f4930583229987d90fe5e8e0b74</span><br></pre></td></tr></table></figure>

<p><code>commit a1</code> 提交的树形图可以表示为</p>
<p><img src="images/git-from-the-inside-out/1-a1-tree-graph.png" alt="a1提交的树形图"></p>
<h2 id="创建一个commit对象"><a href="#创建一个commit对象" class="headerlink" title="创建一个commit对象"></a>创建一个commit对象</h2><hr>
<p><code>git commit</code>在创建完上面的树形图后创建一个commit对象。这个commit对象同样存储在<code>.git/objects</code>中</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">alpha $ git cat-file -t a89e</span><br><span class="line">commit</span><br><span class="line">alpha $ git cat-file -p a89e</span><br><span class="line">tree ffe298c3ce8bb07326f888907996eaa48d266db4</span><br><span class="line">author xiejianxun &lt;<span class="symbol">xiejianxun@</span>outlook.comm&gt; <span class="number">1583742597</span> +<span class="number">0800</span></span><br><span class="line">committer xiejianxun &lt;<span class="symbol">xiejianxun@</span>outlook.comm&gt; <span class="number">1583742597</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">a1</span><br></pre></td></tr></table></figure>
<p>第三行表示<code>commit a1</code>对象指向一个tree对象,后面的数值是这个tree对象的哈希值。这个哈希值上面有提到，它就是表示项目的根目录。在当前环境下，就是<code>alpha</code>目录。倒数三四行表示作者和提交人的信息(之所以分开，是因为有时提交人不一定是作者）,最后一行表示注释。</p>
<p><img src="images/git-from-the-inside-out/2-a1-commit.png" alt="commit a1对应的commit对象指向的树形图"></p>
<h2 id="指向当前分支最新的commit对象"><a href="#指向当前分支最新的commit对象" class="headerlink" title="指向当前分支最新的commit对象"></a>指向当前分支最新的commit对象</h2><hr>
<p><code>git command</code>最后要做的是记录当前分支的最新的commit对象</p>
<p>那么，在哪里记录着当前分支呢？在Git中，<code>HEAD</code> 文件记录着当前工作的分支，文件位于<code>.git/HEAD</code></p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># heads下记录了当前仓库拥有哪些分支</span></span><br><span class="line">alpha $ cat .git/HEAD</span><br><span class="line"><span class="keyword">ref</span>: refs/heads/<span class="literal">master</span></span><br></pre></td></tr></table></figure>

<p><code>HEAD</code>中记录着它指向了<code>master</code>分支，也就是说<code>master</code>就是当前正在工作的分支。</p>
<p><code>HEAD</code>和<code>master</code>都是引用.<code>引用</code>就是Git使用的一个标签或用户用于标识特定提交的<code>tag</code>。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alpha</span> $ <span class="keyword">cat</span> .git/refs/heads/master</span><br><span class="line">a89ea183a48e484c318335fd25c8adcc82608c35</span><br><span class="line"><span class="keyword">alpha</span> $ git <span class="keyword">cat</span>-<span class="keyword">file</span> -t a89e</span><br><span class="line">commit</span><br></pre></td></tr></table></figure>
<p><code>master</code>文件中存储了一个哈希值，它表示一个commit对象。(如果你也跟着做，这个哈希值可能不一致，因为commit对象包含提交用户的信息）</p>
<p>将<code>HEAD</code>和<code>master</code>添加到Git的树形图中的结果如下</p>
<p><img src="images/git-from-the-inside-out/3-a1-refs.png" alt="HEAD指向master，master指向commit a1"></p>
<p>Git 对象都是存储在特殊的文件中(需要<code>git cat-file</code>才能查看里面的内容），<code>master</code>和<code>HEAD</code>存储在普通的文件中(直接用<code>cat</code>命令可以查看内容）</p>
<p>注意：<code>HEAD</code>指向<code>master</code>在commit之前已经完成。<code>master</code>现在指定了最新的commit对象。</p>
<p>以上是第一次提交的情况。</p>
<h2 id="非第一次提交的提交"><a href="#非第一次提交的提交" class="headerlink" title="非第一次提交的提交"></a>非第一次提交的提交</h2><hr>
<p>下面是一个包含了<code>working copy</code>(工作副本)和<code>index</code>(暂存区)的树形图<br><img src="images/git-from-the-inside-out/4-a1-wc-and-index.png" alt="commit a1与工作空间和index之间的关系"></p>
<p>现在<code>working copy</code>、<code>index</code>和<code>commit a1</code>中的<code>data/letter.txt</code>和<code>data/number.txt</code>都含有相同的内容的<code>a</code>和<code>1</code>. <code>index</code>和<code>HEAD</code>都使用哈希值指定它们引用的blob对象，但是工作空间中的内容是用文本存储在不同的地方(<code>alpha</code>目录下)。</p>
<p>执行以下的命令后</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alpha <span class="variable">$</span> printf <span class="string">'2'</span> &gt; <span class="keyword">data</span>/number.txt</span><br><span class="line">alpha <span class="variable">$</span> git add <span class="keyword">data</span>/number.txt</span><br></pre></td></tr></table></figure>

<p>树形图会发生变化:首先工作空间中的<code>data/number.txt</code>文件的发生变化，内容从<code>1</code>变成<code>2</code>. 但是，<code>HEAD</code>,<code>index</code>不会变化,依然指向原来的位置。</p>
<p><img src="images/git-from-the-inside-out/5-a1-wc-number-set-to-2.png" alt="修改工作空间中的文件变化"></p>
<p>执行<code>git add</code>后，<code>index</code>变化。它会在<code>.git/objects</code>下创建一个blob对象，这个对象存储着<code>2</code>.然后，<code>index</code>中的关于<code>data/number.txt</code>的条目的哈希值更改为这个新生成的blob对象的哈希值。</p>
<p><img src="images/git-from-the-inside-out/6-a1-wc-and-index-number-set-to-2.png" alt="git add后index的变化"></p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alpha $ git commit -m 'a2'</span><br><span class="line">[master <span class="number">8734e79</span>] a2</span><br><span class="line"> <span class="number">1</span> file <span class="section">changed</span>, <span class="number">1</span> insertion(+), <span class="number">1</span> deletion(-)</span><br></pre></td></tr></table></figure>
<p>用户再次执行commit后，产生的影响与之前的commit一样.(本次提交使用<code>commit a2</code> 表示后面所有提交类似)</p>
<p>首先，创建一个新的树形图表示<code>index</code>中的内容。</p>
<p>index中的关于<code>data/number.txt</code>的条目发生了变化。代表<code>data</code>目录的旧tree对象将不能表示现在<code>index</code>中表示的状态。所有需要生成一个新的tree对象。</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alpha $ git cat-file -p <span class="number">40b0</span></span><br><span class="line"><span class="number">100644</span> blob 2e65efe2a145dda7ee51d1741299f848e5bf752e    letter.txt</span><br><span class="line"># 与之前的不同</span><br><span class="line"><span class="number">100644</span> blob d8263ee9860594d2806b0dfd1bfd17528b0ba2a4    number.txt</span><br></pre></td></tr></table></figure>
<p>表示<code>data</code>目录的tree对象的哈希值与旧的不同,因此还需要生成新的表示<br><code>alpha</code>的tree对象</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alpha <span class="variable">$</span> git cat<span class="operator">-file</span> <span class="literal">-p</span> ce72</span><br><span class="line"><span class="number">040000</span> tree <span class="number">40</span>b0318811470aaacc577485777d7a6780e51f0b    <span class="keyword">data</span></span><br></pre></td></tr></table></figure>
<p>然后，生成一个新的commit对象:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alpha $ git cat-file -p <span class="number">8734</span></span><br><span class="line">tree ce72afb5ff229a39f6cce47b00d1b0ed60fe3556</span><br><span class="line">parent a89ea183a48e484c318335fd25c8adcc82608c35</span><br><span class="line">author xiejianxun &lt;<span class="symbol">xiejianxun@</span>outlook.comm&gt; <span class="number">1583753450</span> +<span class="number">0800</span></span><br><span class="line">committer xiejianxun &lt;<span class="symbol">xiejianxun@</span>outlook.comm&gt; <span class="number">1583753450</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">a2</span><br></pre></td></tr></table></figure>

<p>第二行指向了新的<code>root</code> tree对象(表示根目录的tree对象称为<code>root</code>,在这里是<code>alpha</code>)。第二行指向了<code>commit a1</code>对象。它是<code>commit a2</code>对象的父亲。为了在生成新的<code>commit a2</code>对象，Git需要先找到父commit对象：Git首先找到<code>HEAD</code>，通过<code>HEAD</code>定位到<code>master</code>，然后通过<code>master</code>找到<code>commit a1</code>对象。</p>
<p>最后，<code>master</code>文件中的内容修改为指定新的commit对象。</p>
<p><img src="images/git-from-the-inside-out/7-a2.png" alt="commit a2"></p>
<p><img src="images/git-from-the-inside-out/8-a2-just-objects-commits-and-refs.png" alt="commit a2 没有工作空间和index的树形图"></p>
<p>从上图可以看出，在<code>commit a2</code>时，<code>data/letter.txt</code>会利用<code>commit</code>中的blob对象，这样可以减少空间占用。</p>
<p>下面总结部分的<strong>树形图属性</strong>：</p>
<ul>
<li><p>项目的内容存储在对象树中。这意味着<code>Git只会存储修改的文件</code>。如果目录下所有文件都没有修改，则会复用整个tree 对象。通常情况下，每次的提供通常只会修改少量内容，所以即使提交了大量commit，空间不会占用太多。</p>
</li>
<li><p>每个commit都有一个父commit(当然，第一个commit没有)。这意味着仓库可以存储项目的整个历史。</p>
</li>
<li><p>引用是历史提交版本的入口。这意味着每次提交都可以指定一个有意义的名称提交名，如<code>fix-for-bug-376</code>。Git还会使用如<code>HEAD</code>、<code>MEGRE_HEAD</code>、<code>FETCH_HEAD</code>的引用，用于操作历史提交版本。</p>
</li>
</ul>
<ul>
<li><p><code>.git/objects</code>下的所有文件是<code>不可修改</code>的。这意味着内容只会被修改，不会被删除。也就是说每次添加和commit的内容都会储存在<code>.git/objects</code>目录下。</p>
</li>
<li><p>引用是可以修改的。比如<code>master</code>当前可能指向目前项目中最好的提交版本，但是，很快就会有更好的提交版本，所以master又会指向这个新提交的版本。</p>
</li>
<li><p>工作空间和引用指向的提交是随时准备好被读取的，但是其他提交版本不是，以上图为例，<code>commit a2</code>的内容可以通过<code>git ckeckout</code> 立即读取到，而a1则不能，还需要查找才可以被读取。</p>
</li>
</ul>
<p>在没有<code>git add</code>之前，Git不会保存用户做的任何修改,所以需要注意保存。<br>HEAD是最容易变化的引用。<br>如果一个提交没有被任何引用记录，将会很难切换到这个提交的版本。</p>
<h2 id="切换到一个提交"><a href="#切换到一个提交" class="headerlink" title="切换到一个提交"></a>切换到一个提交</h2><hr>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">alpha $ git <span class="built_in">ref</span>log</span><br><span class="line"><span class="number">8734e79</span> (HEAD -&gt; master) <span class="symbol">HEAD@</span>&#123;<span class="number">0</span>&#125;: commit: a2</span><br><span class="line">a89ea18 <span class="symbol">HEAD@</span>&#123;<span class="number">1</span>&#125;: commit (initial): a1</span><br><span class="line"></span><br><span class="line">alpha $ git checkout <span class="number">8734</span></span><br><span class="line">Note: switching to <span class="string">'8734'</span>.</span><br><span class="line"></span><br><span class="line">You are <span class="keyword">in</span> <span class="string">'detached HEAD'</span> state.</span><br></pre></td></tr></table></figure>

<p>用户通过哈希值切换到<code>commit a2</code>.(通过<code>git log</code>或<code>reflog</code>可以找到提交的哈希值)</p>
<p>完成<code>git checkout</code>命令需要四个步骤：</p>
<p>第一，Git找到在<code>.git/objects</code>通过<code>git ckeckout</code>命令中的哈希值找到对应的commit对象(<code>commit a2</code>)和它指向的树形图。</p>
<p>第二，Git将树形图中的tree对象和blob对象变成工作空间中相应的目录和文件。由于<code>HEAD</code>通过<code>master</code>已经指向了 <code>commit a2</code>，所有工作空间中的文件不会有变化。</p>
<p>第三，Git将更新<code>index</code>中的条目，由于文件没有变化所以<code>index</code>中的内容也没有变化。</p>
<p>第四，<code>HEAD</code>文件中的内容将会设置会<code>commit a2</code>的哈希值。</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alpha $ cat .git/HEAD</span><br><span class="line"><span class="number">8734e794</span><span class="keyword">c</span><span class="number">8</span>a<span class="number">443</span><span class="keyword">c</span><span class="number">0</span>dc<span class="number">3e04</span><span class="keyword">cc</span><span class="number">91</span>a<span class="number">2</span>f<span class="number">835</span><span class="keyword">c</span><span class="number">77</span>b<span class="number">2</span><span class="keyword">c</span><span class="number">9</span>d</span><br><span class="line">alpha $ git status</span><br><span class="line">HEAD detached at <span class="number">8734e79</span></span><br><span class="line">nothing <span class="keyword">to</span> commit, working tree clean</span><br></pre></td></tr></table></figure>
<p>将<code>HEAD</code>的内容设置为一个哈希值将会使Git仓库进入分离头指针状态( detached HEAD state).</p>
<p>从下图可以看出，<code>HEAD</code>直接指向了<code>commit a2</code>,而不是<code>master</code>。</p>
<p><img src="images/git-from-the-inside-out/9-a2-detached-head.png" alt="处理分离头指针状态"></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alpha <span class="variable">$</span> printf <span class="string">'3'</span> &gt; <span class="keyword">data</span>/number.txt</span><br><span class="line">alpha <span class="variable">$</span> git add <span class="keyword">data</span>/number.txt</span><br><span class="line">alpha <span class="variable">$</span> git commit <span class="literal">-m</span> <span class="string">'a3'</span></span><br><span class="line">[<span class="type">detached</span> <span class="type">HEAD</span> <span class="number">50</span><span class="type">ac643</span>] a3</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+), <span class="number">1</span> deletion(-)</span><br></pre></td></tr></table></figure>
<p>用户将<code>data/number.txt</code>中的内容改变成<code>3</code>，并提交这次更改。Git通过HEAD找到这次提交的父commit。这次查找父commit不会再通过分支引用查找，因为HEAD中直接存储的就是commit对象的哈希值。它返回的是<code>commit a2</code>对象的哈希值。</p>
<p>Git更新的HEAD的值，HEAD同样直接指向了<code>commit a3</code>。仓库依然处于detached HEAD 状态。<code>commit a3</code> 不在任何分支中，这样一旦HEAD从新指向<code>commit a2</code>,  <code>commit a3</code>就会很容易丢失，因为没有任何其他引用指向这次引用。</p>
<p>这次提交的示意图如下(省略了<code>commit a3</code>的tree &amp; blob对象）：</p>
<p><img src="images/git-from-the-inside-out/10-a3-detached-head.png" alt="commit a3处于分离头指针状态"></p>
<h2 id="创建一个分支"><a href="#创建一个分支" class="headerlink" title="创建一个分支"></a>创建一个分支</h2><hr>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">alpha</span> $ git <span class="keyword">branch </span>deputy</span><br></pre></td></tr></table></figure>

<p>用户创建了一个新分支：<code>deputy</code>。这条命令会创建一个新的文件<code>.git/refs/heads/deputy</code>，deputy文件中存储着HEAD的指向的commit对象的哈希值。在这是就是 <code>commit a3</code>的哈希值,这样<code>commit a3</code>就不容易丢失了</p>
<p><strong>树形图属性</strong>：分支就是引用，而引用就是文件，文件中存储着commit的哈希值。这意味着Git的分支是轻量级的。</p>
<p>创建deputy分支使用<code>commit a3</code>安全地保存在这个分支里。HEAD依然处理分离头指针状态。它还是直接指向<code>commit a3</code>.</p>
<p><img src="images/git-from-the-inside-out/11-a3-on-deputy.png" alt="创建分支deputy"></p>
<h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><hr>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alpha $ git checkout <span class="literal">master</span></span><br><span class="line">Previous HEAD position was <span class="number">50</span>ac643 a3</span><br><span class="line">Switched to branch '<span class="literal">master</span>'</span><br></pre></td></tr></table></figure>
<p>用户切换到<code>master</code>分支,这个命令执行以下操作：</p>
<ul>
<li>Git通过<code>master</code>找到<code>commit a2</code>,然后找到<code>commit a2</code> 指向的树形图。</li>
<li>Git将树形图存储的内容写到工作空间中，这样，<code>data/number.txt</code>的内容将会改为<code>2</code>.</li>
<li>Git根据当前工作空间的内容更新<code>index</code>的内容。在这里关于<code>data/number.txt</code>的条目将会更新的。</li>
<li>Git将<code>HEAD</code>指向<code>master</code>分支，即<code>HEAD</code>文件的内容从哈希值变为：<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alpha $ cat .git/HEAD</span><br><span class="line"><span class="built_in">ref</span>: <span class="built_in">ref</span>s/heads/master</span><br></pre></td></tr></table></figure>
对应的树形图为：</li>
</ul>
<p><img src="images/git-from-the-inside-out/12-a3-on-master-on-a2.png" alt="切换到master分支"></p>
<h1 id="切换到一个与当前工作空间不兼容的分支"><a href="#切换到一个与当前工作空间不兼容的分支" class="headerlink" title="切换到一个与当前工作空间不兼容的分支"></a>切换到一个与当前工作空间不兼容的分支</h1><hr>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alpha $ printf <span class="string">'789'</span> &gt; data/<span class="built_in">number</span>.txt</span><br><span class="line">alpha $ git checkout deputy</span><br><span class="line">error: Your <span class="built_in">local</span> changes <span class="built_in">to</span> <span class="keyword">the</span> following <span class="built_in">files</span> would be overwritten <span class="keyword">by</span> checkout:</span><br><span class="line">        data/<span class="built_in">number</span>.txt</span><br><span class="line">Please commit your changes <span class="keyword">or</span> stash them <span class="keyword">before</span> you <span class="keyword">switch</span> branches.</span><br><span class="line">Aborting</span><br></pre></td></tr></table></figure>
<p>假设用户意外将<code>data/number.txt</code>的内容修改为<code>789</code>(还没有保存),然后他尝试切换到分支<code>deputy</code>。但Git阻止了这个动作。</p>
<p><code>HEAD</code>当前指向<code>master</code>，<code>master</code>指定<code>commit a2</code>，这时工作目录下<code>data/number.txt</code>的内容是<code>2</code>.<code>deputy</code>指向<code>commit a3</code>，相应的<code>data/number.txt</code>的内容是<code>3</code>. 工作空间下<code>data/number.txt</code>的内容是<code>789</code>, 这三个版本的内容都是不同的。</p>
<p>当用户在更改<code>data/number.txt</code>内容为<code>789</code>，并切换到<code>deputy</code>时，Git尝试将<code>deputy</code>分支指向的<code>commit a3</code>中的<code>data/number.txt</code>内容写到工作空间，但是这将会导致当前工作空间下<code>data/number.txt</code>的<code>789</code>数据丢失，所以Git阻止这一行为。</p>
<p>Git可以将当前工作空间的内容与将要切换的分支进行合并，但是这个过程是复杂的。所以，Git阻止了这个行为。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alpha <span class="variable">$</span> printf <span class="string">'2'</span> &gt; <span class="keyword">data</span>/number.txt</span><br><span class="line">alpha <span class="variable">$</span> git checkout deputy</span><br><span class="line">Switched to branch <span class="string">'deputy'</span></span><br></pre></td></tr></table></figure>
<p>当用户将之前意外修改的<code>data/number.txt</code> 重新设置为原来的内容，他就可以成功切换分支：</p>
<p><img src="images/git-from-the-inside-out/13-a3ondeputy.png" alt="checkout deputy的问题"></p>
<h2 id="合并一个祖先分支"><a href="#合并一个祖先分支" class="headerlink" title="合并一个祖先分支"></a>合并一个祖先分支</h2><hr>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alpha $ git merge <span class="literal">master</span></span><br><span class="line">Already up to <span class="keyword">date</span>.</span><br></pre></td></tr></table></figure>

<p>用户将<code>master</code>分支合并到<code>deputy</code>。合并两个分支实际就是合并两个commit.第一个commit就是<code>deputy</code>指向的：它是<code>接收者</code>。第二个commit就量<code>master</code>指向的：它是<code>提供者</code>。对于这个合并，Git不会做任何动作。它直接报告Already up to date。</p>
<p><strong>树形图属性</strong>：树形图中的一系列提交可以理解为对内容的一系列修改。这意味着，如果提供者分支是接收者分支的祖先，Git将不会做任何修改，这些修改在接收者分支中早已合并，或者说，接收者分支本身就包含这些信息，既然已经包含，再做其他动作也是无谓的。</p>
<h2 id="合并一个后代分支"><a href="#合并一个后代分支" class="headerlink" title="合并一个后代分支"></a>合并一个后代分支</h2><hr>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alpha $ git checkout <span class="literal">master</span></span><br><span class="line">Switched to branch '<span class="literal">master</span>'</span><br></pre></td></tr></table></figure>
<p>用户先切换到<code>master</code>分支</p>
<p><img src="images/git-from-the-inside-out/14-a3-on-master-on-a2.png" alt="从commit a3 切换到 commit a2"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alpha $ git <span class="keyword">merge</span> deputy</span><br><span class="line"><span class="keyword">Fast</span>-forward</span><br></pre></td></tr></table></figure>
<p>用户将<code>deputy</code>分支合并到<code>master</code>分支。Git发现<code>master</code>这个接收者分支是<code>deputy</code>的祖先分支，它可以做<code>fast-forward</code> 合并。</p>
<p>Git获取到deputy指向的<code>commit a3</code>及它指向的树形图，Git将树形中的内容写到工作空间中，并更新index。这样Git就完成了fast-forward。</p>
<p><img src="images/git-from-the-inside-out/15-a3-on-master.png" alt="master fast-forward"></p>
<p><strong>树形图属性</strong>：树形图中的一系列提交可以理解为对内容的一系列修改。这意味着，在合并的两个分支中，如果提供者分支是接收者分支的后代，版本历史是没有改变的。例如<code>deputy</code>指向的<code>commit a3</code>的历史有<code>a2</code> 和<code>a1</code>. 而<code>master</code>指向的<code>commit a2</code>的历史有<code>a1</code>,这些历史提交版本并没有不同之处。因此，Git直接将<code>HEAD</code>指向到时提供者<code>deputy</code>分支上即可。</p>
<p>以上是两种简单的合并情况，下面是复杂的合并情况</p>
<h2 id="合并两个兄弟分支"><a href="#合并两个兄弟分支" class="headerlink" title="合并两个兄弟分支"></a>合并两个兄弟分支</h2><hr>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alpha <span class="variable">$</span> printf <span class="string">'4'</span> &gt; <span class="keyword">data</span>/number.txt</span><br><span class="line">alpha <span class="variable">$</span> git add <span class="keyword">data</span>/number.txt</span><br><span class="line">alpha <span class="variable">$</span> git commit <span class="literal">-m</span> <span class="string">'a4'</span></span><br><span class="line">[<span class="type">master</span> <span class="number">19</span><span class="type">a5293</span>] a4</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+), <span class="number">1</span> deletion(-)</span><br></pre></td></tr></table></figure>
<p>用户修改<code>master</code>分支下的<code>data/number.txt</code>，并提交修改</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alpha $ git checkout deputy</span><br><span class="line">Switched to branch 'deputy'</span><br><span class="line">alpha $ <span class="built_in">printf</span> 'b' &gt; data/letter.txt</span><br><span class="line">alpha $ git add data/letter.txt</span><br><span class="line">alpha $ git commit -m 'b3';</span><br><span class="line">[deputy <span class="number">070b587</span>] b3</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+), <span class="number">1</span> deletion(-)</span><br></pre></td></tr></table></figure>
<p>用户切换到<code>deputy</code>分支，并修改<code>data/letter.txt</code> ，并提交修改。两个分支的操作结果用树形图表示为：</p>
<p><img src="images/git-from-the-inside-out/16-a4-b3-on-deputy.png" alt="commit a4 和commit b3"></p>
<p><strong>树形图属性</strong>：不同的commit可以共有一个父commit。这意味着在提交历史中可以有两个或多个不同的后代分支。</p>
<p><strong>树形图属性</strong>：commit可以拥有多个父commit。这意味着两个分离的分支可以合并成一个分支。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alpha $ git <span class="keyword">merge</span> <span class="keyword">master</span> -m <span class="string">'b4'</span></span><br><span class="line"><span class="keyword">Merge</span> made <span class="keyword">by</span> the <span class="string">'recursive'</span> strategy.</span><br><span class="line"> <span class="keyword">data</span>/number.txt | <span class="number">2</span> +-</span><br><span class="line"> <span class="number">1</span> <span class="keyword">file</span> <span class="keyword">changed</span>, <span class="number">1</span> insertion(+), <span class="number">1</span> deletion(-)</span><br></pre></td></tr></table></figure>
<p>用户将<code>master</code>合并到<code>deputy</code>。</p>
<p>Git发现<code>接收者</code>分支<code>commit b3</code> 和<code>提供者</code>分支<code>commit a4</code>是属于旁系分支(之前的是直系分支），合并这种分支需要八个步骤：</p>
<p>第一，Git将的<code>提供者</code>分支的哈希值写到文件<code>.git/MERGE_HEAD</code>中，这个文件的存在告诉Git正处理合并中。</p>
<p>第二，Git先找到两个分支的最后共同祖先，在这里是<code>commit a3</code></p>
<p><img src="images/git-from-the-inside-out/17-a4-b3-on-deputy.png" alt="共同祖先分支commit a3"></p>
<p><strong>树形图属性</strong>：commit拥有父commit。这意味着两个不同世系的commit可以找到一个共同的祖先commit。Git通过commit对象中保存的父commit对象查找，最终，找到<code>commit a3</code>为<code>commit b3</code>和<code>commit a4</code>的共同祖先.</p>
<p>第三，Git从<code>commit a3</code>、<code>commit b3</code> 、<code>commit a4</code>指向的树形图中生成各自的<code>index</code>,这个<code>index</code>就如同之前的一样，包含了git保存的所有文件的信息。</p>
<p>第四，Git通过以<code>commit a3</code>为的<code>index</code>基础，将<code>commit a4</code>和<code>commit b3</code>的<code>index</code>与之对比，通过对比决定对文件做哪些操作，这些操作将写入到一个<code>diff</code>缓冲区，这个<code>diff</code>里面的条目包含文件路径，并且标记这些文件的变化类型：<em>增加、删除、修改、冲突</em>。</p>
<p>在这里，<code>diff</code>中有两个条目：</p>
<ul>
<li>一个条目关于<code>data/letter.txt</code>。这个文件的内容在<code>commit a3</code> 是<code>a</code>, 在<code>commit b3</code>是<code>b</code>, <code>commit a4</code>中是<code>a</code>.因此存在不同。但是<code>commit a3</code>和<code>commit a4</code>中是一致的。Git检测到文件内容被<code>接收方</code>分支修改，但<code>提供方</code>分支没有修改。因此，diff条目中关于<code>data/letter.txt</code>的变化类型是 <code>修改</code>。</li>
<li>另一条是关于<code>data/number.txt</code>。这个文件的内容在接收方commit 和父commit中相同，提供方commit中不同。因此，diff条目中关于<code>data/number.txt</code>的变化类型同样的修改。</li>
</ul>
<p><strong>树形图属性</strong>：一般都能找到合并的父commit。这意味着，如果文件只在接收方分支或提供方分支中修改了，那么Git可以自动解决这个文件的合并问题，这样可以减少用户的工作。</p>
<p>第五，diff条目中显示的修改被生成到工作空间。也就是<code>data/letter.txt</code>的内容设置为<code>b</code>,<code>data/number.txt</code>的内容设置为<code>4</code>.</p>
<p>第六，将工作目录下的变化更新的<code>index</code>.<code>index</code>中关于<code>data/letter.txt</code>的条目将指向包含内容为<code>b</code>的blob对象，关于<code>data/number.txt</code>的条目将指向包含内容为<code>4</code>的blob对象。</p>
<p>第七，提交<code>index</code>中保存的内容。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">alpha $ git cat-file -p d206</span><br><span class="line">tree <span class="number">20294508</span>aea3fb6f05fcc49adaecc2e6d60f7e7d</span><br><span class="line">parent <span class="number">070</span>b5874053a20c332b811678e8c309ba4012a8b</span><br><span class="line">parent <span class="number">19</span>a52935ef77e9a25597f1e397692208aa440bd3</span><br><span class="line">author xiejianxun &lt;<span class="symbol">xiejianxun@</span>outlook.comm&gt; <span class="number">1583763966</span> +<span class="number">0800</span></span><br><span class="line">committer xiejianxun &lt;<span class="symbol">xiejianxun@</span>outlook.comm&gt; <span class="number">1583763966</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">b4</span><br></pre></td></tr></table></figure>
<p>可以看出<code>commit b4</code>有两个父commit。</p>
<p>第八，Git将<code>HEAD</code>指向当前分支<code>deputy</code>的最新提交。</p>
<p>所有步骤的最后结果用树形图表示为</p>
<p><img src="images/git-from-the-inside-out/18-b4-on-deputy.png" alt="合并两个旁系分支"></p>
<h2 id="合并两个来自旁系分支且它们修改同一文件"><a href="#合并两个来自旁系分支且它们修改同一文件" class="headerlink" title="合并两个来自旁系分支且它们修改同一文件"></a>合并两个来自旁系分支且它们修改同一文件</h2><hr>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alpha $ git checkout master</span><br><span class="line">alpha $ git merge deputy</span><br><span class="line">Updating <span class="number">19</span>a5293..d206abe</span><br><span class="line">Fast-forward</span><br><span class="line"> data/letter.txt | <span class="number">2</span> +-</span><br><span class="line"> <span class="number">1</span> file <span class="section">changed</span>, <span class="number">1</span> insertion(+), <span class="number">1</span> deletion(-)</span><br></pre></td></tr></table></figure>
<p>用户切换到时<code>master</code>分支，并将<code>deputy</code>分支合并到<code>master</code>分支。这个动作的结果是master fast-forward到<code>commit b4</code>。现在<code>master</code>与<code>deputy</code>都指向同一个commit。</p>
<p><img src="images/git-from-the-inside-out/19-b4-master-deputy-on-b4.png" alt="master fast forward"></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alpha <span class="variable">$</span> git checkout deputy</span><br><span class="line">Switched to branch <span class="string">'deputy'</span></span><br><span class="line">alpha <span class="variable">$</span> printf <span class="string">'5'</span> &gt; <span class="keyword">data</span>/number.txt</span><br><span class="line">alpha <span class="variable">$</span> git add <span class="keyword">data</span>/number.txt</span><br><span class="line">alpha <span class="variable">$</span> git commit <span class="literal">-m</span> <span class="string">'b5'</span></span><br><span class="line">[<span class="type">deputy</span> <span class="number">5840214</span>] b5</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+), <span class="number">1</span> deletion(-)</span><br></pre></td></tr></table></figure>
<p>用户切换到<code>deputy</code>，将<code>data/number.txt</code>的内容改变为<code>5</code>，并提交修改。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alpha $ git checkout <span class="literal">master</span></span><br><span class="line">Switched to branch '<span class="literal">master</span>'</span><br><span class="line">alpha $ printf '<span class="number">6</span>' &gt; data/<span class="keyword">number</span>.txt</span><br><span class="line">alpha $ git add data/<span class="keyword">number</span>.txt</span><br><span class="line">alpha $ git commit -m 'b6'</span><br><span class="line">[<span class="keyword">master</span> <span class="title">0163655</span>] b6</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+), <span class="number">1</span> deletion(-)</span><br></pre></td></tr></table></figure>

<p>用户切换到<code>master</code>，将<code>data/number.txt</code>的内容改变为<code>6</code>，并提交修改。</p>
<p><img src="images/git-from-the-inside-out/20-b5-on-deputy-b6-on-master.png" alt="两个旁系分支修改同一文件"></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alpha $ git merge deputy</span><br><span class="line">Auto-merging data/number.txt</span><br><span class="line"><span class="keyword">CONFLICT</span> (content): Merge <span class="keyword">conflict</span> <span class="keyword">in</span> data/number.txt</span><br><span class="line">Automatic merge failed; fix conflicts <span class="keyword">and</span> <span class="keyword">then</span> <span class="keyword">commit</span> the result.</span><br></pre></td></tr></table></figure>

<p>用户想将<code>deputy</code>合并到git，但是出现冲突导致合并中止。合并冲突处理的前六个步骤与不冲突的合并处理一样：</p>
<ul>
<li>第一，生成<code>.git/MERGE_HEAD</code></li>
<li>第二，找到共同的父commit。</li>
<li>第三，生成父commit、接收方commit和提供方commit的index。</li>
<li>第四，根据index，创建一个diff。</li>
<li>第五，更新的工作空间。</li>
<li>第六，更新的index。</li>
</ul>
<p>由于冲突，第七和第八步不会发生。下面再次分析这些过程看看发生了什么。</p>
<p>第一，Git将提供方commit的哈希值写到文件<code>.git/MERGE_HEAD</code>.</p>
<p><img src="images/git-from-the-inside-out/21-b6-on-master-with-merge-head.png" alt="MERGE_HEAD"></p>
<p>第二，Git找到双方的最近的父commit，这里是<code>commit b4</code>.</p>
<p>第三，Git通过父commit、提供方commit、接收方commit分别生成它们的<code>index</code>。</p>
<p>第四，Git生成一个diff，里面组合了三个commit的更改信息。这个diff里面是一些文件路径，并且标明这些文件发生的修改是：添加、删除、修改还是冲突。</p>
<p>根据这次合并的情况，diff中只含有一个条目：<code>data/number.txt</code>。这个条目标识了<code>data/number.txt</code>合并过程中发生<code>冲突</code>，因为<code>data/number.txt</code>在三个commit中的内容都不相同，因此<code>Git无法决定怎样合并</code>。</p>
<p>第五，diff中显示冲突的条目被标识到工作空间中的<code>data/number.txt</code>中。对于冲突区域，Git将所有冲突信息写到工作空间中的<code>data/number.txt</code>中。下面是工作空间中的<code>data/number.txt</code>的内容。</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alpha $ cat data/number.txt</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">6</span><br><span class="line">=======</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; deputy</span><br></pre></td></tr></table></figure>
<p>第六，Git将diff中的条目更新到<code>index</code>中，<code>index中</code>的条目通过文件路径和状态唯一标识一个文件。没有冲突的的条目它的状态是用0表示。在这次合并前，<code>index</code>的内容大概如下：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alpha $ git ls-files --stage</span><br><span class="line"><span class="number">100644</span> <span class="number">63</span>d8dbd40c23542e740659a7168a0ce3138ea748 <span class="number">0</span>       data/letter.txt</span><br><span class="line"><span class="number">100644</span> <span class="number">62f</span>9457511f879886bb7728c986fe10b0ece6bcb <span class="number">0</span>       data/number.txt</span><br></pre></td></tr></table></figure>
<p>当<code>index</code>中写入diff中的信息时，<code>index</code>的内容大概如下：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alpha $ **git ls-files --stage**</span><br><span class="line"><span class="number">100644</span> <span class="number">63</span>d8dbd40c23542e740659a7168a0ce3138ea748 <span class="number">0</span>       data/letter.txt</span><br><span class="line"><span class="number">100644</span> bf0d87ab1b2b0ec1a11a3973d2845b42413d9767 <span class="number">1</span>       data/number.txt</span><br><span class="line"><span class="number">100644</span> <span class="number">62f</span>9457511f879886bb7728c986fe10b0ece6bcb <span class="number">2</span>       data/number.txt</span><br><span class="line"><span class="number">100644</span> <span class="number">7813681f</span>5b41c028345ca62a2be376bae70b7f61 <span class="number">3</span>       data/number.txt</span><br></pre></td></tr></table></figure>

<p><code>data/letter.txt</code>对应的条目状态为0，与将diff信息写入<code>index</code>前相同。<code>data/number.txt</code>的状态不再是<code>0</code>.有三个条目关于<code>data/number.txt</code>。状态为<code>1</code>的条目有父commit中<code>data/number.txt</code>对应的哈希值。状态为<code>2</code>的条目有接收方commit中<code>data/number.txt</code>对应的哈希值。状态为<code>3</code>的条目有提供方commit中<code>data/number.txt</code> 对应的哈希值。有这三个条目的存在说明合并存在冲突,所以合并中止了。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alpha <span class="variable">$</span> printf <span class="string">'11'</span> &gt; <span class="keyword">data</span>/number.txt</span><br><span class="line">alpha <span class="variable">$</span> git add <span class="keyword">data</span>/number.txt</span><br></pre></td></tr></table></figure>

<p>用户对<code>data/number.txt</code>的冲突内容进行修改为<code>11</code>，然后通过<code>git add</code>将内容添加到<code>index</code>。Git生成一个包含<code>11</code>的blob对象。添加冲突文件到<code>index</code>会告诉Git冲突已经解决。Git将删除index中状态为<code>1,2,3</code>的条目，并添加一条状态为<code>0</code>，指向新生成blob对象的项目，现在<code>index</code>的内容如下：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alpha $ git add dgit ls-files --stage</span><br><span class="line"><span class="number">100644</span> <span class="number">63</span>d8dbd40c23542e740659a7168a0ce3138ea748 <span class="number">0</span>       data/letter.txt</span><br><span class="line"><span class="number">100644</span> <span class="number">9</span>d607966b721abde8931ddd052181fae905db503 <span class="number">0</span>       data/number.txt</span><br><span class="line"></span><br><span class="line">alpha $ git commit -m <span class="string">'b11'</span></span><br><span class="line">[master <span class="number">5</span>c673b4] b11</span><br></pre></td></tr></table></figure>
<p>由于用户解决了冲突，<code>git commit</code>会完成之前没有完成的第七和第八步。</p>
<p>第七，用户提交冲突修改，Git发现仓库中有<code>.git/MERGE_HEAD</code>,这个文件告诉Git合并正在处理中，然后Git检查<code>index</code>并发生没有冲突。Git创建一个新的<code>commit b11</code>.用于记录解决了冲突的合并。并且Git会删除<code>.git/MERGE_HEAD</code>.到这一步已经完成合并工作。</p>
<p>第八，Git将<code>HEAD</code>指向当前分支<code>master</code>最新的<code>commit b11</code>.</p>
<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><hr>
<p>下图是树形图包含所有历史commit、最新的commit包含的tree&amp;blob对象和工作空间及<code>index</code>：</p>
<p><img src="images/git-from-the-inside-out/23-b11-with-objects-wc-and-index.png" alt="当前状态下完整的树形图"></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">alpha</span> $ git rm <span class="class"><span class="keyword">data</span>/letter.txt</span></span><br><span class="line"><span class="title">rm</span> '<span class="class"><span class="keyword">data</span>/letter.txt'</span></span><br></pre></td></tr></table></figure>

<p>用户告知Git删除了<code>data/letter.txt</code>文件。此时工作空间中的文件被删除，<code>index</code>中关于<code>data/letter.txt</code>的条目也被删除，说明Git不再追踪此文件。</p>
<p><img src="images/git-from-the-inside-out/24-b11-letter-removed-from-wc-and-index.png" alt="删除文件"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alpha $ git <span class="keyword">commit</span> -m <span class="string">'11'</span></span><br><span class="line">[<span class="keyword">master</span> <span class="number">1</span>f727e1] <span class="number">11</span></span><br><span class="line"> <span class="number">1</span> <span class="keyword">file</span> <span class="keyword">changed</span>, <span class="number">1</span> deletion(-)</span><br><span class="line"> <span class="keyword">delete</span> <span class="keyword">mode</span> <span class="number">100644</span> <span class="keyword">data</span>/letter.txt</span><br></pre></td></tr></table></figure>

<p>用户提交了删除文件的修改。用于根据<code>index</code>中的内容生成一个新的树形图表示<code>index</code>中的内容。<code>data/letter.txt</code>不再包含在这个新的树形图中，因为它不在<code>index</code>中。</p>
<p><img src="images/git-from-the-inside-out/25-11.png" alt="删除提交后的树形图"></p>
<h2 id="复制一个仓库"><a href="#复制一个仓库" class="headerlink" title="复制一个仓库"></a>复制一个仓库</h2><hr>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">alpha</span></span> <span class="symbol">$</span> cd ..</span><br><span class="line">git <span class="symbol">$</span> cp -R alpha bravo</span><br><span class="line">git <span class="symbol">$</span> ls</span><br><span class="line">alpha  bravo</span><br></pre></td></tr></table></figure>

<p>用户将文件夹<code>alpha</code>中的所有内容复制到<code>bravo</code>文件夹中。现在git的目录结构如下：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git $ tree</span><br><span class="line">.</span><br><span class="line">|<span class="comment">-- alpha</span></span><br><span class="line">|   `<span class="comment">-- data</span></span><br><span class="line">|       `<span class="comment">-- number.txt</span></span><br><span class="line">`<span class="comment">-- bravo</span></span><br><span class="line">    `<span class="comment">-- data</span></span><br><span class="line">        `<span class="comment">-- number.txt</span></span><br></pre></td></tr></table></figure>
<p>现在，<code>bravo</code>目录下同样包含一个树形图：</p>
<p><img src="images/git-from-the-inside-out/26-11-cp-alpha-to-bravo.png" alt="复制git仓库"></p>
<h2 id="连接两个Git仓库中"><a href="#连接两个Git仓库中" class="headerlink" title="连接两个Git仓库中"></a>连接两个Git仓库中</h2><hr>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="symbol">$</span> cd alpha/</span><br><span class="line"><span class="function"><span class="title">alpha</span></span> <span class="symbol">$</span> git remote add bravo ../bravo</span><br></pre></td></tr></table></figure>
<p>用户重新的进入<code>alpha</code>仓库，他将<code>bravo</code>设为一个远程仓库。这个操作会被记录在<code>.git/config</code>中。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alpha <span class="variable">$ </span>cat .git/config</span><br><span class="line">省略部分内容...</span><br><span class="line">[remote <span class="string">"bravo"</span>]</span><br><span class="line">        url = ../bravo</span><br><span class="line">        fetch = +refs/heads/*<span class="symbol">:refs/remotes/bravo/*</span></span><br></pre></td></tr></table></figure>
<p>上面的内容表示有一个远程仓库叫 <code>bravo</code>，它的本地文件系统中，地址是<code>../bravo</code>.</p>
<h2 id="从远程仓库中取出一个分支"><a href="#从远程仓库中取出一个分支" class="headerlink" title="从远程仓库中取出一个分支"></a>从远程仓库中取出一个分支</h2><hr>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">alpha</span></span> <span class="symbol">$</span> cd ../bravo</span><br><span class="line">bravo <span class="symbol">$</span> printf <span class="string">'12'</span> &gt; data/number.txt</span><br><span class="line">bravo <span class="symbol">$</span> git add data/number.txt</span><br><span class="line">bravo <span class="symbol">$</span> git commit -m <span class="string">'12'</span></span><br><span class="line">[master f8f1d2c] <span class="number">12</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">file</span> changed, <span class="number">1</span> insertion(+), <span class="number">1</span> deletion(-)</span><br></pre></td></tr></table></figure>

<p>用户在<code>bravo</code>仓库中将<code>data/number.txt</code>的内容修改为<code>12</code>并提交本次修改。结果如下：</p>
<p><img src="images/git-from-the-inside-out/27-12-bravo.png" alt="bravo仓库修改后"></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bravo $ cd ../alpha/</span><br><span class="line">alpha $ git fetch bravo master</span><br><span class="line">remote: Enumerating objects: <span class="number">7</span>, done.</span><br><span class="line">remote: Counting objects: <span class="number">100</span>% (<span class="number">7</span>/<span class="number">7</span>), done.</span><br><span class="line">remote: Total <span class="number">4</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">Unpacking objects: <span class="number">100</span>% (<span class="number">4</span>/<span class="number">4</span>), done.</span><br><span class="line">From ../bravo</span><br><span class="line"> * branch            master     -&gt; FETCH_HEAD</span><br><span class="line"> * [new branch]      master     -&gt; bravo/master</span><br></pre></td></tr></table></figure>

<p>用户重新的回到<code>alpha</code>仓库，并从<code>bravo</code>中获取<code>master</code>分支到<code>alpha</code>中。这个过程分为四步：</p>
<p>第一，Git获取<code>bravo</code>中<code>master</code>分支指向的commit的哈希值。在这里是<code>commit 12</code>对应的哈希值。</p>
<p>第二，Git列出<code>bravo</code>仓库中<code>commit 12</code>依赖的所有对象：commit 对象， tree对象、blob对象、所有祖先commit对象及它们对应的树形图包含的对象。然后Git删除<code>alpha</code>仓库中已经包含的对象。最后将剩余不同复制到<code>aplha/.git/objects</code>.</p>
<p>第三，记录<code>commit 12</code>的哈希值。创建<code>alpha/.git/refs/remotes/bravo/master</code>,并且内容设置为指向<code>commit 12</code>的哈希值。</p>
<p>第四，<code>alpha/.git/FETCH_HEAD</code>的内容设置为</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">f8f1d2c62a3666b80910e2182867a45d9040b48e</span></span>                branch <span class="string">'master'</span> of ../bravo</span><br></pre></td></tr></table></figure>
<p>这表明最新的的<code>fetch</code>命令从<code>bravo</code>中获取了<code>master</code>分支的<code>f8f1</code>指向的commit对象。</p>
<p><img src="images/git-from-the-inside-out/28-12-fetched-to-alpha.png" alt="从远程仓库获取分支"></p>
<p><strong>树形图属性</strong>：对象是可以复制的。这意味着整个仓库的历史可以在不同的仓库中共享。</p>
<p><strong>树形图属性</strong>：一个仓库可以存储远程仓库的分支引用如<code>alpha/.git/refs/remotes/bravo/master</code>.这意味仓库中可以将本地状态存储在远程仓库中。如果远程仓库更新的了，那么本地获取的分支将会过时。</p>
<h2 id="合并FETCH-HEAD"><a href="#合并FETCH-HEAD" class="headerlink" title="合并FETCH_HEAD"></a>合并FETCH_HEAD</h2><hr>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alpha $ git merge FETCH_HEAD</span><br><span class="line">Updating <span class="number">1</span>f727e1..f8f1d2c</span><br><span class="line">Fast-forward</span><br><span class="line"> data/number.txt | <span class="number">2</span> +-</span><br><span class="line"> <span class="number">1</span> file <span class="section">changed</span>, <span class="number">1</span> insertion(+), <span class="number">1</span> deletion(-)</span><br></pre></td></tr></table></figure>
<p>用户将<code>FETCH_HEAD</code>指向的分支合并到<code>master</code>分支中。注意<code>FETCH_HEAD</code>也只不过是一个引用而已。这个过程与先前的合并本地分支没有什么不同，在这里，Git做了一个fast-forward合并，将<code>master</code>指向了<code>commit 12</code>. 合并后的树形图表示如下：</p>
<p><img src="images/git-from-the-inside-out/29-12-merged-to-alpha.png" alt="master fast forward to commit 12"></p>
<h2 id="从-远程仓库中拉取一个分支"><a href="#从-远程仓库中拉取一个分支" class="headerlink" title="从 远程仓库中拉取一个分支"></a>从 远程仓库中拉取一个分支</h2><hr>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alpha $ git pull bravo <span class="literal">master</span></span><br><span class="line">From ../bravo</span><br><span class="line"> * branch            <span class="keyword">master</span>     <span class="title">-&gt; FETCH_HEAD</span></span><br><span class="line">Already up to <span class="keyword">date</span>.</span><br></pre></td></tr></table></figure>
<p>用户将<code>bravo</code>中的<code>master</code>分支拉取到本地仓库中。<code>pull</code>其实就是 <code>fetch</code>和<code>merge FETCH_HEAD</code>的合并操作。Git完成这两个命令后，并报告master is Already up to date.</p>
<h2 id="克隆一个仓库"><a href="#克隆一个仓库" class="headerlink" title="克隆一个仓库"></a>克隆一个仓库</h2><hr>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">alpha</span></span> <span class="symbol">$</span> cd ..</span><br><span class="line">git <span class="symbol">$</span> git clone alpha charlie</span><br><span class="line"><span class="function"><span class="title">Cloning</span></span> into <span class="string">'charlie'</span>...</span><br><span class="line">done.</span><br><span class="line">git <span class="symbol">$</span> ls</span><br><span class="line">alpha  bravo  charlie</span><br></pre></td></tr></table></figure>
<p>用户在移动到git目录下。他克隆<code>alpha</code>仓库存储在<code>charlie</code>。克隆的<code>charlie</code>仓库与之前<code>cp</code>命令生成的<code>bravo</code>仓库类似。Git创建一个新的目录<code>charlie</code>，将<code>charlie</code>初始化为一个Git仓库。将<code>alpha</code>作为一个远程仓库。将<code>alpha</code>这个远程仓库命名为<code>origin</code>.使用<code>fetch origin</code>并<code>merge FETCH_HEAD</code>.</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git $ cat charlie/.git/config</span><br><span class="line">[core]</span><br><span class="line">        <span class="attr">repositoryformatversion</span> = <span class="number">0</span></span><br><span class="line">        <span class="attr">filemode</span> = <span class="literal">true</span></span><br><span class="line">        <span class="attr">bare</span> = <span class="literal">false</span></span><br><span class="line">        <span class="attr">logallrefupdates</span> = <span class="literal">true</span></span><br><span class="line">[remote <span class="string">"origin"</span>]</span><br><span class="line">        <span class="attr">url</span> = /root/git/alpha</span><br><span class="line">        <span class="attr">fetch</span> = +refs/heads<span class="comment">/*:refs/remotes/origin/*</span></span><br><span class="line"><span class="comment">[branch "master"]</span></span><br><span class="line"><span class="comment">        remote = origin</span></span><br><span class="line"><span class="comment">        merge = refs/heads/master</span></span><br></pre></td></tr></table></figure>

<h2 id="推送分支到远程仓库中一个被签出的分支中"><a href="#推送分支到远程仓库中一个被签出的分支中" class="headerlink" title="推送分支到远程仓库中一个被签出的分支中"></a>推送分支到远程仓库中一个被签出的分支中</h2><hr>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="variable">$</span> cd alpha/</span><br><span class="line">alpha <span class="variable">$</span> printf <span class="string">'13'</span> &gt; <span class="keyword">data</span>/number.txt</span><br><span class="line">alpha <span class="variable">$</span> git add <span class="keyword">data</span>/number.txt</span><br><span class="line">alpha <span class="variable">$</span> git commit <span class="literal">-m</span> <span class="string">'13'</span></span><br><span class="line">[<span class="type">master</span> <span class="type">b92ab33</span>] <span class="number">13</span></span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+), <span class="number">1</span> deletion(-)</span><br></pre></td></tr></table></figure>
<p>用户进入<code>alpha</code>仓库，修改<code>data/number.txt</code>文件的内容为<code>13</code>.并提交这次修改为<code>commit 13</code>.</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">alpha</span></span> <span class="symbol">$</span> git remote add charlie ../charlie</span><br></pre></td></tr></table></figure>
<p>将<code>charlie</code>设置为<code>alpha</code>的一个远程仓库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">alpha $ git push charlie master</span><br><span class="line">Enumerating objects: 7, done.</span><br><span class="line">Counting objects: 100% (7/7), done.</span><br><span class="line">Writing objects: 100% (4/4), 277 bytes | 277.00 KiB/s, done.</span><br><span class="line">Total 4 (delta 0), reused 0 (delta 0)</span><br><span class="line">remote: error: refusing to <span class="keyword">update</span> checked <span class="keyword">out</span> branch: refs/heads/<span class="keyword">master</span></span><br><span class="line">remote: <span class="keyword">error</span>: <span class="keyword">By</span> <span class="keyword">default</span>, updating the <span class="keyword">current</span> branch <span class="keyword">in</span> a non-bare repository</span><br><span class="line">remote: <span class="keyword">is</span> denied, because it will make the <span class="keyword">index</span> <span class="keyword">and</span> <span class="keyword">work</span> tree inconsistent</span><br><span class="line">remote: <span class="keyword">with</span> what you pushed, <span class="keyword">and</span> will require <span class="string">'git reset --hard'</span> <span class="keyword">to</span> <span class="keyword">match</span></span><br><span class="line">remote: the <span class="keyword">work</span> tree <span class="keyword">to</span> HEAD.</span><br><span class="line">remote:</span><br><span class="line">remote: You can <span class="keyword">set</span> the <span class="string">'receive.denyCurrentBranch'</span> configuration <span class="keyword">variable</span></span><br><span class="line">remote: <span class="keyword">to</span> <span class="string">'ignore'</span> <span class="keyword">or</span> <span class="string">'warn'</span> <span class="keyword">in</span> the remote repository <span class="keyword">to</span> <span class="keyword">allow</span> pushing <span class="keyword">into</span></span><br><span class="line">remote: its <span class="keyword">current</span> branch; however, this is not recommended unless you</span><br><span class="line">remote: arranged to <span class="keyword">update</span> its <span class="keyword">work</span> tree <span class="keyword">to</span> <span class="keyword">match</span> what you pushed <span class="keyword">in</span> <span class="keyword">some</span></span><br><span class="line">remote: other way.</span><br><span class="line">remote:</span><br><span class="line">remote: <span class="keyword">To</span> squelch this message <span class="keyword">and</span> still <span class="keyword">keep</span> the <span class="keyword">default</span> behaviour, <span class="keyword">set</span></span><br><span class="line">remote: <span class="string">'receive.denyCurrentBranch'</span> configuration <span class="keyword">variable</span> <span class="keyword">to</span> <span class="string">'refuse'</span>.</span><br><span class="line"><span class="keyword">To</span> ../charlie</span><br><span class="line"> ! [remote rejected] <span class="keyword">master</span> -&gt; <span class="keyword">master</span> (branch <span class="keyword">is</span> currently checked <span class="keyword">out</span>)</span><br><span class="line"><span class="keyword">error</span>: <span class="keyword">failed</span> <span class="keyword">to</span> push <span class="keyword">some</span> refs <span class="keyword">to</span> <span class="string">'../charlie'</span></span><br></pre></td></tr></table></figure>
<p>用户将<code>alpha</code>的<code>master</code>分支推送到<code>charlie</code>中</p>
<p><code>commit 13</code>所关联的所有对象都被复制到<code>charlie</code>仓库中。</p>
<p>这时，<strong>推送操作失败</strong>。Git向用户说明了失败的原因。远程仓库中的分支被<code>checkout</code>到工作空间中，<code>alpha</code>的<code>push</code>操作会更新远程仓库的<code>index</code>和<code>HEAD</code>。如果有人远程仓库的工作空间中编辑，<code>push</code>操作将会导致混乱。所以Git阻止推送操作。</p>
<p>但是，用户想建一个仓库中，用户可以随时推送到这个仓库中，下面将建立这个一个仓库：</p>
<h2 id="克隆一个裸仓库"><a href="#克隆一个裸仓库" class="headerlink" title="克隆一个裸仓库"></a>克隆一个裸仓库</h2><hr>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">alpha</span></span> <span class="symbol">$</span> cd ..</span><br><span class="line">git <span class="symbol">$</span> git clone alpha delta --bare</span><br><span class="line"><span class="function"><span class="title">Cloning</span></span> into bare repository <span class="string">'delta'</span>...</span><br><span class="line">done.</span><br></pre></td></tr></table></figure>

<p>用户克隆一个裸仓库。这个克隆操作与之后的克隆有所不同。config文件表示这个仓库是<code>bare</code>的。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">delta $ cat config</span><br><span class="line">[core]</span><br><span class="line">        repositoryformatversion = 0</span><br><span class="line">        filemode = <span class="literal">true</span></span><br><span class="line">        *<span class="number">*ba</span>re = <span class="literal">true</span>**</span><br><span class="line">[remote <span class="string">"origin"</span>]</span><br><span class="line">        url = /root/git/alpha</span><br></pre></td></tr></table></figure>

<p>所有原本存储在<code>.git</code>中的文件现在都存储在根目录中。并且没有了原本工作空间中的文件。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bare repo</span></span><br><span class="line">delta $ ls</span><br><span class="line">branches <span class="built_in"> config </span> description  HEAD  hooks  <span class="builtin-name">info</span>  objects  packed-refs  refs</span><br><span class="line"></span><br><span class="line"><span class="comment"># ordinary repo</span></span><br><span class="line">delta $ ls <span class="built_in">..</span>/alpha/  <span class="built_in">..</span>/alpha/.git -ah</span><br><span class="line"><span class="built_in">..</span>/alpha/:</span><br><span class="line">.  <span class="built_in">..</span>  data  .git</span><br><span class="line"></span><br><span class="line">**<span class="built_in">..</span>/alpha/.git:**</span><br><span class="line">.   branches       <span class="built_in"> config </span>      FETCH_HEAD  hooks  <span class="builtin-name">info</span>  objects    refs</span><br><span class="line"><span class="built_in">..</span>  COMMIT_EDITMSG  description  HEAD        index  logs  ORIG_HEAD</span><br></pre></td></tr></table></figure>

<p><img src="images/git-from-the-inside-out/30-13-alpha-cloned-to-delta-bare.png" alt="裸仓库"></p>
<h2 id="推送一个分支到bare仓库中"><a href="#推送一个分支到bare仓库中" class="headerlink" title="推送一个分支到bare仓库中"></a>推送一个分支到bare仓库中</h2><hr>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">delta</span></span> <span class="symbol">$</span> cd ../alpha/</span><br><span class="line"><span class="function"><span class="title">alpha</span></span> <span class="symbol">$</span> git remote add delta ../delta</span><br><span class="line">alpha <span class="symbol">$</span> printf <span class="string">'14'</span> &gt; data/number.txt</span><br><span class="line">alpha <span class="symbol">$</span> git commit -am<span class="string">'14'</span></span><br><span class="line">[master f001318] <span class="number">14</span></span><br><span class="line"> <span class="number">1</span> <span class="keyword">file</span> changed, <span class="number">1</span> insertion(+), <span class="number">1</span> deletion(-)</span><br></pre></td></tr></table></figure>

<p>用户进入<code>alpha</code>仓库，将<code>delta</code>设置远程仓库，修改<code>data/number.txt</code>中的内容为<code>14</code>，并提交这次操作。</p>
<p><img src="images/git-from-the-inside-out/31-14-alpha.png" alt="更新alpha"></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alpha $ git push delta master</span><br><span class="line">Enumerating objects: <span class="number">7</span>, done.</span><br><span class="line">Counting objects: <span class="number">100</span>% (<span class="number">7</span>/<span class="number">7</span>), done.</span><br><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">4</span>/<span class="number">4</span>), <span class="number">276</span> bytes | <span class="number">276.00</span> KiB/s, done.</span><br><span class="line">Total <span class="number">4</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">To ../delta</span><br><span class="line">   b92ab33..f001318  master -&gt; master</span><br></pre></td></tr></table></figure>

<p>用户将<code>alpha</code>的<code>master</code>分支推送到<code>delta</code>。这个<code>push</code>操作分为三步：</p>
<p>第一，<code>alpha</code>的<code>master</code>分支中的<code>commit 14</code>所需要的所有对象将会从<code>alpha/.git/objects</code>复制到<code>delta/objects</code>中。</p>
<p>第二，<code>delta/refs/heads/master</code>更新的<code>commit 14</code></p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">delta $ cat HEAD</span><br><span class="line"><span class="keyword">ref</span>: refs/heads/<span class="literal">master</span></span><br><span class="line">delta $ cat refs/heads/<span class="literal">master</span></span><br><span class="line">f0013185d0a45ecf7f7be00692ddfa6359954513</span><br><span class="line"></span><br><span class="line">delta $ cd ../alpha</span><br><span class="line">alpha $ cat .git/HEAD</span><br><span class="line"><span class="keyword">ref</span>: refs/heads/<span class="literal">master</span></span><br><span class="line">alpha $ cat .git/refs/heads/<span class="literal">master</span></span><br><span class="line">f0013185d0a45ecf7f7be00692ddfa6359954513</span><br></pre></td></tr></table></figure>
<p>第三，<code>alpha/.git/refs/remotes/delta/master</code>更新为指向<code>commit 14</code>这时，<code>alpha</code>将自己的最新状态同步到<code>delta</code>中。</p>
<p><img src="images/git-from-the-inside-out/32-14-pushed-to-delta.png" alt="推送到裸仓库"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr>
<p>Git建立在这个抽象的树形图中。几乎所有的Git命令都会操作这个树形图。要想深入理解Git，重点关注这个树形图的属性，而不是死记命令。<br>因此，为了深入学习Git，探索.git目录中的内容是不可避免。</p>
<p>文中还没有涉及到的命令：</p>
<ul>
<li><code>git prune</code> 用于删除一个引用无法关联到的所有对象，如果用户运行这个命令，会导致内容的丢失。</li>
<li><code>git stash</code> 将工作空间中与HEAD指向的提交之间的diff存储在一个安全的地方，它们可以在后面被检索出来。用于临时保存内容。</li>
<li><code>git rebase</code>这个命今用于添加、编辑和删除objects中存储的commit。</li>
<li>…</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://github.com/yvkm/2020/04/02/Git%20from%20the%20inside%20out/" data-id="ck8jvao4s0001ooapgm90g4rw" class="article-share-link" data-share="baidu" data-title="深入浅出Git原理">分享到</a>
      

      

      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/" rel="tag">git</a></li></ul>

    </footer>
  </div>
  
</article>


  

</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Framework/">Spring Framework</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BeanFactory/" rel="tag">BeanFactory</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Framework/" rel="tag">Spring Framework</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/BeanFactory/" style="font-size: 10px;">BeanFactory</a> <a href="/tags/Spring-Framework/" style="font-size: 10px;">Spring Framework</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/03/BeanFactory/">BeanFactory</a>
          </li>
        
          <li>
            <a href="/2020/04/02/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">Redis分布式锁</a>
          </li>
        
          <li>
            <a href="/2020/04/02/Git%20from%20the%20inside%20out/">深入浅出Git原理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 yvkm<br>
      Powered by <a href="//hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>





<script src="/js/script.js"></script>


</div>
</body>
</html>
